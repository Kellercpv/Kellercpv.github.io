<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>mysql | Blog</title><meta name="author" content="Kellercpv"><meta name="copyright" content="Kellercpv"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="mysqlMyISAM 和 InnoDB 有什么区别？123456789MySQL5.5之前默认引擎是MyISAM，现在是InnoDB。区别：1、InnoDB支持行锁表锁，MyISAM只支持表锁2、MyISAM不支持事务，InnoDB支持事务，并实现了SQL标准定义四个隔离级别3、MyISAM不支持外键，InnoDB支持外键4、MyISAM不支持MVCC，InnoDB支持MVCC5、虽然 MyIS">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql">
<meta property="og:url" content="http://example.com/2023/12/21/mysql/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="mysqlMyISAM 和 InnoDB 有什么区别？123456789MySQL5.5之前默认引擎是MyISAM，现在是InnoDB。区别：1、InnoDB支持行锁表锁，MyISAM只支持表锁2、MyISAM不支持事务，InnoDB支持事务，并实现了SQL标准定义四个隔离级别3、MyISAM不支持外键，InnoDB支持外键4、MyISAM不支持MVCC，InnoDB支持MVCC5、虽然 MyIS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://telegraph-image-5ol.pages.dev/file/b1d43ca4dc69e9e978992.jpg">
<meta property="article:published_time" content="2023-12-20T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-10T07:28:13.172Z">
<meta property="article:author" content="Kellercpv">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://telegraph-image-5ol.pages.dev/file/b1d43ca4dc69e9e978992.jpg"><link rel="shortcut icon" href="https://telegraph-image-5ol.pages.dev/file/41ea36a938166256d6bc8.jpg"><link rel="canonical" href="http://example.com/2023/12/21/mysql/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mysql',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-10 15:28:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://telegraph-image-5ol.pages.dev/file/41ea36a938166256d6bc8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://telegraph-image-5ol.pages.dev/file/b1d43ca4dc69e9e978992.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">mysql</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-20T16:00:00.000Z" title="发表于 2023-12-21 00:00:00">2023-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-10T07:28:13.172Z" title="更新于 2024-03-10 15:28:13">2024-03-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/">关系型数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="mysql"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="MyISAM-和-InnoDB-有什么区别？"><a href="#MyISAM-和-InnoDB-有什么区别？" class="headerlink" title="MyISAM 和 InnoDB 有什么区别？"></a>MyISAM 和 InnoDB 有什么区别？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MySQL5<span class="number">.5</span>之前默认引擎是MyISAM，现在是InnoDB。</span><br><span class="line">区别：</span><br><span class="line"><span class="number">1</span>、InnoDB支持行锁表锁，MyISAM只支持表锁</span><br><span class="line"><span class="number">2</span>、MyISAM不支持事务，InnoDB支持事务，并实现了SQL标准定义四个隔离级别</span><br><span class="line"><span class="number">3</span>、MyISAM不支持外键，InnoDB支持外键</span><br><span class="line"><span class="number">4</span>、MyISAM不支持MVCC，InnoDB支持MVCC</span><br><span class="line"><span class="number">5</span>、虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</span><br><span class="line"><span class="number">6</span>、MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</span><br><span class="line"><span class="number">7</span>、InnoDB 的性能比 MyISAM 更强大</span><br></pre></td></tr></table></figure>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</span><br><span class="line">索引底层数据结构存在很多种类型，常见的索引结构有：B树，B+树和Hash、红黑树。在MySQL中，无论是InnoDB还是MyISAM，都使用B+树作为索引结构。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line"><span class="number">1</span>、使用索引可以大大加快数据的检索速度（大大减少检索的数据量）</span><br><span class="line"><span class="number">2</span>、创建唯一索引，可以保证数据库表中每一行数据的唯一性。</span><br><span class="line">缺点：</span><br><span class="line"><span class="number">1</span>、创建索引和维护索引需要耗费许多时间，当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQl执行效率。</span><br><span class="line"><span class="number">2</span>、索引需要使用物理文件存储，也会耗费一定空间。</span><br></pre></td></tr></table></figure>

<h3 id="索引底层数据结构选型"><a href="#索引底层数据结构选型" class="headerlink" title="索引底层数据结构选型"></a>索引底层数据结构选型</h3><h4 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">哈希表可以通过hash算法，快速找到key对应index，即可快速取出对应的值。因此哈希表可以快速检索数据。</span><br><span class="line">哈希表这么快，为什么MySQL没有使用其作为索引的数据结构呢？</span><br><span class="line">主要是因为Hash索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那Hash索引可就不行了。并且每次IO只能取一个。</span><br><span class="line">SELECT * FROM tb1 WHERE id &lt; <span class="number">500</span>;</span><br><span class="line">在这种范围查询中，Hash索引需要把<span class="number">1</span>-<span class="number">499</span>的数据都进行一次hash计算定位数据。</span><br></pre></td></tr></table></figure>

<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二叉查找树具有以下特点：</span><br><span class="line">左子树所有节点的值均小于根节点的值。</span><br><span class="line">右子树所有节点的值均大于根节点的值。</span><br><span class="line">左右子树也分别为二叉查找树。</span><br><span class="line">当二叉查找树是平衡的时候，查询的时间复杂度为O（log2（N）），具有较高的效率。当二叉树不平衡时，最坏情况下，时间复杂度退化为O（N）。二叉查找树的性能非常依赖于他的平衡程度，所以不适合作为MySQL索引底层数据结构</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/842ee2bdba6bb32c5421b.png"></p>
<h4 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVL树是一种自平衡二叉查找树，AVL树的特点是保证任何结点的左右子树高度之差不超过<span class="number">1</span>，查找，插入，删除平均情况和最坏情况下的时间复杂度都是O（logn）</span><br><span class="line">缺点：</span><br><span class="line"><span class="number">1</span>、由于AVL树需要频繁的进行旋转操作来保持平衡，因此会有较大的计算开销降低了查询性能。</span><br><span class="line"><span class="number">2</span>、每个节点存储一个数据，每次磁盘IO时只能读取一个节点的数据，当需要查询的数据分布在多个节点上，那么就需要进行多次磁盘IO。</span><br><span class="line"></span><br><span class="line">磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。</span><br></pre></td></tr></table></figure>

<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，特点：</span><br><span class="line"><span class="number">1</span>、每个节点非红即黑；</span><br><span class="line"><span class="number">2</span>、根节点总是黑色的；</span><br><span class="line"><span class="number">3</span>、每个叶子节点都是黑色的空节点（NIL 节点）；</span><br><span class="line"><span class="number">4</span>、如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</span><br><span class="line"><span class="number">5</span>、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/e229e5273a256390b5c76.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">和AVL树不同，红黑树并不追求严格的平衡，而是大致的平衡。</span><br><span class="line">优点：</span><br><span class="line">红黑树插入和删除操作效率大大提高，红黑树在插入和删除节点只需要进行O（<span class="number">1</span>）次旋转和变色操作，即可保持平衡，而AVL树需要O（logn）次旋转操作。</span><br><span class="line">缺点：</span><br><span class="line">红黑树查询效率稍有下降，因为红黑树平衡性较弱。</span><br><span class="line">一些数据需要进行多次磁盘IO操作才能查询到，这也是MySQL没有选择红黑树的主要原因。</span><br><span class="line">红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1<span class="number">.8</span> 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</span><br></pre></td></tr></table></figure>

<h4 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B 树和 B+ 树"></a>B 树和 B+ 树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B 树也称B-树,全称为多路平衡查找树，B+树是B树的一种变体。</span><br></pre></td></tr></table></figure>

<h5 id="B-树和-B-树区别"><a href="#B-树和-B-树区别" class="headerlink" title="B 树和 B+ 树区别"></a>B 树和 B+ 树区别</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</span><br><span class="line"><span class="number">2</span>、B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</span><br><span class="line"><span class="number">3</span>、B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</span><br><span class="line"><span class="number">4</span>、在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</span><br><span class="line">综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</span><br></pre></td></tr></table></figure>

<h4 id="非聚簇索引和聚簇索引"><a href="#非聚簇索引和聚簇索引" class="headerlink" title="非聚簇索引和聚簇索引"></a>非聚簇索引和聚簇索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyISAM引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引（非聚集索引）</span><br><span class="line">    </span><br><span class="line">InnoDB 引擎中，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（聚集索引），而其余的索引都作为 辅助索引 ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。</span><br><span class="line">在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</span><br></pre></td></tr></table></figure>

<h3 id="索引类型总结"><a href="#索引类型总结" class="headerlink" title="索引类型总结"></a>索引类型总结</h3><h4 id="数据结构划分"><a href="#数据结构划分" class="headerlink" title="数据结构划分"></a>数据结构划分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。</span><br><span class="line">哈希索引：类似键值对的形式，一次即可定位。</span><br><span class="line">RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</span><br><span class="line">全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</span><br></pre></td></tr></table></figure>

<h4 id="底层存储方式划分"><a href="#底层存储方式划分" class="headerlink" title="底层存储方式划分"></a>底层存储方式划分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB中的主键索引就属于聚簇索引。</span><br><span class="line">非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引（辅助索引）就属于非聚簇索引。MyISAM引擎不管主键还是非主键，使用的都是非聚簇索引。</span><br></pre></td></tr></table></figure>

<h4 id="应用维度划分"><a href="#应用维度划分" class="headerlink" title="应用维度划分"></a>应用维度划分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">主键索引：加速查询+列表唯一（不可以有NULL）+表中只有一个。</span><br><span class="line">普通索引：加速查询</span><br><span class="line">唯一索引：加速查询+列表唯一（可以有NULL）</span><br><span class="line">覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</span><br><span class="line">联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</span><br><span class="line">全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</span><br></pre></td></tr></table></figure>

<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据表的主键使用的就是主键索引。</span><br><span class="line">一张数据表只能有一个主键，并且主键不能为NULL，不能重复。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/6d66ae1efd90ef6108c1b.png"></p>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说通过二级主键，可以也只能定位主键位置。</span><br><span class="line">唯一索引，普通索引，前缀索引等索引属于二级索引。</span><br><span class="line">唯一索引（Unique Key）:建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</span><br><span class="line">普通索引（Index）:</span><br><span class="line">前缀索引(Prefix):前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</span><br><span class="line">全文索引（Full Text）:</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/6d66ae1efd90ef6108c1b.png"></p>
<h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB中的主键索引就属于聚簇索引。</span><br></pre></td></tr></table></figure>

<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line"><span class="number">1</span>、查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</span><br><span class="line"><span class="number">2</span>、对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。</span><br><span class="line">缺点：</span><br><span class="line"><span class="number">1</span>、依赖于有序的数据：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</span><br><span class="line"><span class="number">2</span>、更新代价大：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</span><br></pre></td></tr></table></figure>

<h4 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">非聚簇索引即索引结构和数据分开存放的素银，并不是一种单独的索引类型。二级索引（辅助索引）就属于非聚簇索引。MyISAM引擎，不管主键还是非主键，使用的都是非聚簇索引。</span><br><span class="line">非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据</span><br></pre></td></tr></table></figure>

<h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line"><span class="number">1</span>、更新代价比聚簇索引要小。非聚簇索引的叶子节点是不存放数据的。</span><br><span class="line">缺点：</span><br><span class="line"><span class="number">1</span>、依赖于有序的数据</span><br><span class="line"><span class="number">2</span>、可能会二次查询（回表）：当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</span><br></pre></td></tr></table></figure>

<h4 id="非聚簇索引一定回表查询吗"><a href="#非聚簇索引一定回表查询吗" class="headerlink" title="非聚簇索引一定回表查询吗"></a>非聚簇索引一定回表查询吗</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">非聚簇索引不一定回表查询。</span><br><span class="line">假设用户名有索引，当查询语句只需要查询用户名时，查到对应name就直接返回，无需回表查询</span><br></pre></td></tr></table></figure>

<h3 id="覆盖索引和联合索引"><a href="#覆盖索引和联合索引" class="headerlink" title="覆盖索引和联合索引"></a>覆盖索引和联合索引</h3><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果一个索引包含所有需要查询的字段的值，我们就称之为 覆盖索引（Covering Index） 。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</span><br><span class="line">    </span><br><span class="line">所以覆盖索引指的是一种情况,即索引的字段刚好能满足查询需求，不需要回表即可满足查询的情况。</span><br><span class="line">覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</span><br><span class="line">比如刚刚的非聚簇索引不一定回表查询的情况，就是覆盖索引。</span><br></pre></td></tr></table></figure>

<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用多个字段创建索引就是联合索引。</span><br></pre></td></tr></table></figure>

<h4 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最左前缀匹配原则指的是，在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 &gt;、&lt; ）才会停止匹配。对于 &gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ">全网都在说一个错误的结论 (qq.com)</a></p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引下推（Index Condition Pushdown） 是 MySQL <span class="number">5.6</span> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</span><br></pre></td></tr></table></figure>

<h3 id="正确使用索引的一些建议"><a href="#正确使用索引的一些建议" class="headerlink" title="正确使用索引的一些建议"></a>正确使用索引的一些建议</h3><h3 id="锁加在索引上如何理解"><a href="#锁加在索引上如何理解" class="headerlink" title="锁加在索引上如何理解"></a>锁加在索引上如何理解</h3><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL日志主要包裹错误日志，查询日志，慢查询日志，事务日志，二进制日志几大类。其中比较重要的是二进制日志binlog（归档日志）和事务日志redolog（重做日志）和回滚日志undolog</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/628d76e5886cc9c4cb60d.png"></p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redo log（重做日志，事务日志）是InnoDB存储引擎特有的，它让MySQL拥有了崩溃恢复能力。</span><br><span class="line">当MySQL宕机了，重启时InnoDB存储引擎会使用redo log恢复数据，，保证数据的持久性与完整性。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/7faff3b662e0921325aa0.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MySQL中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。</span><br><span class="line">后续的查询都是先从 Buffer Pool中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。</span><br><span class="line">更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/223dcbd519f28faf14fa0.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">具体刷盘时机根据策略进行。</span><br><span class="line">每条redo记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</span><br></pre></td></tr></table></figure>

<h4 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InnoDB将redo log刷到磁盘上有几种情况：</span><br><span class="line"><span class="number">1</span>、事务提交：当事务提交时，log buffer里的redo log会被刷新到磁盘。</span><br><span class="line"><span class="number">2</span>、log buffer空间不足时：log buffer中缓存的redo log已经占满了log buffer总容量大约一半左右，就需要把这些日志刷新到磁盘上。</span><br><span class="line"><span class="number">3</span>、事务日志缓冲区满时：InnoDB 使用一个事务日志缓冲区（transaction log buffer）来暂时存储事务的重做日志条目。当缓冲区满时，会触发日志的刷新，将日志写入磁盘。</span><br><span class="line"><span class="number">4</span>、Checkpoint（检查点）：InnoDB 定期会执行检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。</span><br><span class="line"><span class="number">5</span>、后台刷新线程：InnoDB 启动了一个后台线程，负责周期性（每隔 <span class="number">1</span> 秒）地将脏页（已修改但尚未写入磁盘的数据页）刷新到磁盘，并将相关的重做日志一同刷新。</span><br><span class="line"><span class="number">6</span>、正常关闭服务器：MySQL 关闭的时候，redo log 都会刷入到磁盘里去。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以通过设置innodb_flush_log_at_trx_commit选择刷盘策略。</span><br><span class="line">innodb_flush_log_at_trx_commit的值有<span class="number">3</span>种，也就是有三种刷盘策略：</span><br><span class="line"><span class="number">0</span>：设置为<span class="number">0</span>的时候，表示每次事务提交时不进行刷盘操作。这种方式性能最高，但是也最不安全，因为如果MySQL挂了或者宕机了，可能会丢失最近<span class="number">1</span>秒内的事务。</span><br><span class="line"><span class="number">1</span>：设置为 <span class="number">1</span> 的时候，表示每次事务提交时都将进行刷盘操作。这种方式性能最低，但是也最安全，因为只要事务提交成功，redo log 记录就一定在磁盘里，不会有任何数据丢失。</span><br><span class="line"><span class="number">2</span>：设置为 <span class="number">2</span> 的时候，表示每次事务提交时都只把 log buffer 里的 redo log 内容写入 page cache（文件系统缓存）。page cache 是专门用来缓存文件的，这里被缓存的文件就是 redo log 文件。这种方式的性能和安全性都介于前两者中间。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了保证事务的持久性，必须设置为<span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h4 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">硬盘上存储的redo log日志文件是以日志文件组的形式出现，每个redo log日志文件大小都是一样的。</span><br><span class="line">比如可以配置一组<span class="number">4</span>个文件。</span><br><span class="line">它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/4059871cd38e435bc0231.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint</span><br><span class="line">write pos 是当前记录的位置，一边写一边后移</span><br><span class="line">checkpoint 是当前要擦除的位置，也是往后推移</span><br><span class="line">    </span><br><span class="line">每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。</span><br><span class="line">每次 MySQL 加载日志文件组恢复数据时，会清空加载过的redo log记录，并把 checkpoint 后移更新。write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/f31d0657e3a8de73eee8d.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果 write pos 追上checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/ecf38596b47d62049c1c1.png"></p>
<h4 id="redo-log-小结"><a href="#redo-log-小结" class="headerlink" title="redo log 小结"></a>redo log 小结</h4><h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redo log是物理日志，记录内容是“在某个数据页做了什么修改”，属于InnoDB存储引擎。</span><br><span class="line">而binlog是逻辑日志，记录内容是语句的原始逻辑，类似于“给ID=<span class="number">2</span>这一行c字段加<span class="number">1</span>”，属于MySQL Server层</span><br><span class="line">不管什么存储引擎，只要产生表数据更新，都会产生binlog日志。</span><br></pre></td></tr></table></figure>

<h4 id="binlog-到底是用来干嘛的？"><a href="#binlog-到底是用来干嘛的？" class="headerlink" title="binlog 到底是用来干嘛的？"></a>binlog 到底是用来干嘛的？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/0354d53b0cb4fa2d9e633.png"></p>
<h4 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">binlog日志有三种格式，可以通过binlog_format参数指定。</span><br><span class="line">statement</span><br><span class="line">row</span><br><span class="line">mixed</span><br></pre></td></tr></table></figure>

<h5 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定statement格式，记录的内容是SQL语句原文，比如执行一条update T set update_time=now() where id=<span class="number">1</span>，记录的内容如下。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/1b1c3a1c450d53297799f.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是有个问题，当同步数据时，update_time=now()会获取当前系统时间，会导致数据不一致。为了解决这个问题，需要指定row格式。</span><br></pre></td></tr></table></figure>

<h5 id="row"><a href="#row" class="headerlink" title="row"></a>row</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row格式记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/fc888a094e0272e237784.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">row格式记录的内容看不到详细信息，要通过mysqlbinlog工具解析出来。</span><br><span class="line">update_time=now()变成了具体的时间update_time=<span class="number">1627112756247</span>，条件后面的@<span class="number">1</span>、@<span class="number">2</span>、@<span class="number">3</span> 都是该行数据第 <span class="number">1</span> 个~<span class="number">3</span> 个字段的原始值（假设这张表只有 <span class="number">3</span> 个字段）。</span><br><span class="line">这样就能保证同步数据的一致性。</span><br><span class="line">但是这种格式需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。</span><br><span class="line">所以有一种折中方式，mixed，记录内容是前两者混合。</span><br></pre></td></tr></table></figure>

<h5 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL会判断这条SQL语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式。</span><br></pre></td></tr></table></figure>

<h4 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h4><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redo log（重做日志）让InnoDB存储引擎拥有了崩溃恢复能力。</span><br><span class="line">binlog（归档日志）保证了MySQL集群架构的数据一致性。</span><br><span class="line">虽然它们都属于持久化的保证，但是侧重点不同。</span><br><span class="line">在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/c686fac543e1b7821c130.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们以update语句为例，假设id=<span class="number">2</span>的记录，字段c值是<span class="number">0</span>，把字段c值更新成<span class="number">1</span>，</span><br><span class="line">SQL语句为update T set c=<span class="number">1</span> where id=<span class="number">2</span>。</span><br><span class="line">假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢？</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/ae5492e016c3bb084bd0b.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。因此，之后用binlog日志恢复数据时，就会少这一次更新，恢复出来的这一行c值是<span class="number">0</span>，而原库因为redo log日志恢复，这一行c值是<span class="number">1</span>，最终数据不一致。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/d0e58755e58a9e984279a.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用两阶段提交方案。</span><br><span class="line">原理很简单，将redo log的写入拆成了两个步骤prepare和commit，这就是两阶段提交。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/c0576705bdaa3a829d155.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用**两阶段提交**后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/c01d55f89517c3d1b9786.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">再看一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</span><br><span class="line">并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/c01d55f89517c3d1b9786.png"></p>
<h3 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">undo log主要有两个作用：</span><br><span class="line">当事务回滚时用于将数据恢复到修改前的样子</span><br><span class="line">另一个作用是MVCC，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过undo log读取之前的版本数据，以此实现非锁定读</span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事务是逻辑上要一组操作要么全部执行，要么全部不执行</span><br></pre></td></tr></table></figure>

<h3 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ACID:</span><br><span class="line">原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</span><br><span class="line">一致性：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的 </span><br><span class="line">隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</span><br><span class="line">持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响 </span><br><span class="line">这里要额外补充一点：只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</span><br></pre></td></tr></table></figure>

<h3 id="并发事务带来什么问题"><a href="#并发事务带来什么问题" class="headerlink" title="并发事务带来什么问题"></a>并发事务带来什么问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</span><br><span class="line">例如：事务 <span class="number">1</span> 读取某表中的数据 A=<span class="number">20</span>，事务 <span class="number">1</span> 修改 A=A-<span class="number">1</span>，事务 <span class="number">2</span> 读取到 A = <span class="number">19</span>,事务 <span class="number">1</span> 回滚导致对 A 的修改并未提交到数据库， A 的值还是 <span class="number">20</span>。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/1a19d504e7169507b2f63.png"></p>
<h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务 <span class="number">1</span> 读取某表中的数据A=<span class="number">20</span>，事务 <span class="number">2</span> 也读取 A=<span class="number">20</span>，事务 <span class="number">1</span> 先修改 A=A-<span class="number">1</span>，事务 <span class="number">2</span> 后来也修改 A=A-<span class="number">1</span>，最终结果 A=<span class="number">19</span>，事务 <span class="number">1</span> 的修改被丢失。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/43c7ce0d40b85a94006f9.png"></p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。例如：事务 <span class="number">1</span> 读取某表中的数据 A=<span class="number">20</span>，事务 <span class="number">2</span> 也读取 A=<span class="number">20</span>，事务 <span class="number">1</span> 修改 A=A-<span class="number">1</span>，事务 <span class="number">2</span> 再次读取 A =<span class="number">19</span>，此时读取的结果和第一次读取的结果不同。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/507a6ed82383644083638.png"></p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。例如：事务 <span class="number">2</span> 读取某个范围的数据，事务 <span class="number">1</span> 在这个范围插入了新的数据，事务 <span class="number">2</span> 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/29b5d2953aaec14393e25.png"></p>
<h4 id="不可重复读和幻读有什么区别"><a href="#不可重复读和幻读有什么区别" class="headerlink" title="不可重复读和幻读有什么区别"></a>不可重复读和幻读有什么区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</span><br><span class="line">幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</span><br><span class="line">注意：记录减少是不可重复读。update和delete是不可重复读，insert是幻读</span><br><span class="line">    </span><br><span class="line">幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。举个例子：执行 delete 和 update 操作的时候，可以直接对记录加锁，保证事务安全。而执行 insert 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 insert 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</span><br></pre></td></tr></table></figure>

<h3 id="并发事务的控制方式有哪些"><a href="#并发事务的控制方式有哪些" class="headerlink" title="并发事务的控制方式有哪些"></a>并发事务的控制方式有哪些</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL中的并发事务控制方式分为两种：锁和MVCC。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</span><br></pre></td></tr></table></figure>

<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">锁 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过读写锁来实现并发控制。</span><br><span class="line">共享锁（S锁），又称为读锁，事务在读取记录时获取共享锁，允许多个事务同时获取（锁兼容）</span><br><span class="line">排他锁（x锁），又称为写锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</span><br><span class="line">读写锁可以做到读读并行，但是无法做到写读、写写并行</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据根据锁粒度的不同，又被分为 表级锁(table-level locking) 和 行级锁(row-level locking) 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</span><br></pre></td></tr></table></figure>

<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</span><br><span class="line">READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</span><br><span class="line">REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。MySQL默认隔离级别。</span><br><span class="line">SERIALIZABLE（可串行化）：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/71982df79bc6f60860753.png"></p>
<h2 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a>锁</h2><h3 id="表级锁和行级锁"><a href="#表级锁和行级锁" class="headerlink" title="表级锁和行级锁"></a>表级锁和行级锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表级锁：是针对非索引字段加的锁，对当前操作的整张表加锁，资源消耗少，不会出现死锁。不过容易发生冲突，高并发下效率低。</span><br><span class="line">行级锁：是针对索引字段加的锁，只针对当前操作的行记录进行加锁。资源消耗大，会出现死锁，但大大减少冲突，高并发下效率高。</span><br></pre></td></tr></table></figure>

<h3 id="行级锁的使用有什么注意事项"><a href="#行级锁的使用有什么注意事项" class="headerlink" title="行级锁的使用有什么注意事项"></a>行级锁的使用有什么注意事项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 UPDATE、DELETE 语句时，如果 WHERE条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</span><br><span class="line">不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、怎么理解行锁是针对索引字段加的锁，表锁是针对非索引字段加的锁，索引不同会怎么样？</span><br><span class="line"><span class="number">2</span>、整理加锁情况，锁优化情况，锁退化情况</span><br></pre></td></tr></table></figure>

<h3 id="行锁分类"><a href="#行锁分类" class="headerlink" title="行锁分类"></a>行锁分类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MySQL有三种行锁：</span><br><span class="line">记录锁（Record Lock）：也被称为记录锁，属于单个行记录上的锁。</span><br><span class="line">间隙锁（Gap Lock）：锁定一个范围，不包括记录本身。</span><br><span class="line">临键锁（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</span><br></pre></td></tr></table></figure>

<h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前面有记录</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">由于MVCC存在，对于一般的SELECT语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</span><br><span class="line">    </span><br><span class="line"># 共享锁 可以在 MySQL <span class="number">5.7</span> 和 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br><span class="line"># 共享锁 可以在 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line">SELECT ... FOR SHARE;</span><br><span class="line"># 排他锁</span><br><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那为什么由于MVCC存在，select不加锁，delete，insert，update又是怎样呢</span><br></pre></td></tr></table></figure>

<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><h3 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h3><h3 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">快照读（一致性非锁定读）就是单纯的 SELECT 语句，但不包括下面这两类 SELECT 语句：</span><br><span class="line">SELECT ... FOR UPDATE</span><br><span class="line"># 共享锁 可以在 MySQL <span class="number">5.7</span> 和 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br><span class="line"># 共享锁 可以在 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line">SELECT ... FOR SHARE;</span><br></pre></td></tr></table></figure>

<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MVCC是InnoDB引擎特有的</span><br><span class="line">MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</span><br></pre></td></tr></table></figure>

<h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、读操作（SELECT）：</span><br><span class="line">当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体工作情况如下：</span><br><span class="line"><span class="number">1</span>、对于读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。</span><br><span class="line"><span class="number">2</span>、如果某个数据行有多个版本，事务会选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。</span><br><span class="line"><span class="number">3</span>、事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、写操作（INSERT、UPDATE、DELETE）：</span><br><span class="line">当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库。具体工作情况如下：</span><br><span class="line"><span class="number">1</span>、对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。</span><br><span class="line"><span class="number">2</span>、新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。</span><br><span class="line"><span class="number">3</span>、原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、事务提交和回滚：</span><br><span class="line"><span class="number">1</span>、当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。</span><br><span class="line"><span class="number">2</span>、当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、版本的回收：</span><br><span class="line">为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。</span><br></pre></td></tr></table></figure>

<h3 id="一致性非锁定读和锁定读"><a href="#一致性非锁定读和锁定读" class="headerlink" title="一致性非锁定读和锁定读"></a>一致性非锁定读和锁定读</h3><h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于一致性非锁定读的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + <span class="number">1</span> 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见</span><br><span class="line"></span><br><span class="line">在 InnoDB 存储引擎中，多版本控制就是对非锁定读的实现。**如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会去等待行上锁的释放。相反地，InnoDB 存储引擎会去读取行的一个快照数据**，对于这种读取历史数据的方式，我们叫它快照读。</span><br><span class="line">在Repeatable Read 和Read Committed两个隔离级别下，如果是执行普通的 select 语句（不包括 select ... lock in share mode ,select ... <span class="keyword">for</span> update）则会使用一致性非锁定读（MVCC）。并且在 Repeatable Read 下 MVCC 实现了可重复读和防止部分幻读</span><br></pre></td></tr></table></figure>

<h4 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果执行的是下列语句，就是锁定读（Locking Reads）</span><br><span class="line">select ... lock in share mode</span><br><span class="line">select ... <span class="keyword">for</span> update</span><br><span class="line">insert、update、delete 操作</span><br><span class="line"></span><br><span class="line">在锁定读下，读取的是数据的最新版本，这种读也被称为当前读（current read）。锁定读会对读取到的记录加锁：</span><br><span class="line">select ... lock in share mode：对记录加 S 锁，其它事务也可以加S锁，如果加 x 锁则会被阻塞</span><br><span class="line">select ... <span class="keyword">for</span> update、insert、update、delete：对记录加 X 锁，且其它事务不能加任何锁</span><br><span class="line"></span><br><span class="line">在一致性非锁定读下，即使读取的记录已被其它事务加上 X 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在Repeatable Read 下MVCC防止了部分幻读，这边的 “部分” 是指在一致性非锁定读 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是如果是当前读 ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， **InnoDB 在实现Repeatable Read时，如果执行的是当前读，则会对读取的记录使用 Next-key Lock ，来防止其它事务在间隙间插入数据**</span><br></pre></td></tr></table></figure>

<h3 id="InnoDB-对-MVCC-的实现"><a href="#InnoDB-对-MVCC-的实现" class="headerlink" title="InnoDB 对 MVCC 的实现"></a>InnoDB 对 MVCC 的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVCC的实现依赖于：**隐藏字段、Read View、undo log**。在内部实现中，InnoDB通过数据行的DB_TRX_ID 和Read View来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</span><br></pre></td></tr></table></figure>

<h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在内部，InnoDB 存储引擎为每行数据添加了三个 隐藏字段：</span><br><span class="line">DB_TRX_ID（<span class="number">6</span>字节）：表示最后一次插入或更新该行的事务 id。此外，delete 操作在内部被视为更新，只不过会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除</span><br><span class="line">DB_ROLL_PTR（<span class="number">7</span>字节） 回滚指针，指向该行的 undo log 。如果该行未被更新，则为空</span><br><span class="line">DB_ROW_ID（<span class="number">6</span>字节）：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引</span><br></pre></td></tr></table></figure>

<h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadView</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  trx_id_t m_low_limit_id;      <span class="comment">/* 大于等于这个 ID 的事务均不可见 */</span></span><br><span class="line"></span><br><span class="line">  trx_id_t m_up_limit_id;       <span class="comment">/* 小于这个 ID 的事务均可见 */</span></span><br><span class="line"></span><br><span class="line">  trx_id_t m_creator_trx_id;    <span class="comment">/* 创建该 Read View 的事务ID */</span></span><br><span class="line"></span><br><span class="line">  trx_id_t m_low_limit_no;      <span class="comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span></span><br><span class="line"></span><br><span class="line">  ids_t m_ids;                  <span class="comment">/* 创建 Read View 时的活跃事务列表 */</span></span><br><span class="line"></span><br><span class="line">  m_closed;                     <span class="comment">/* 标记 Read View 是否 close */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主要有以下字段：</span><br><span class="line">m_low_limit_id：目前出现过的最大的事务ID+<span class="number">1</span>，即下一个将被分配的事务ID。大于等于这个ID的数据版本均不可见</span><br><span class="line">m_up_limit_id：活跃事务列表 m_ids 中最小的事务 ID，如果 m_ids 为空，则 m_up_limit_id 为 m_low_limit_id。小于这个 ID 的数据版本均可见</span><br><span class="line">m_ids：Read View创建时其他未提交的活跃事务ID列表。创建Read View时，将当前未提交事务ID记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。m_ids不包括当前事务自己和已提交的事务（正在内存中）</span><br><span class="line">m_creator_trx_id：创建该 Read View 的事务 ID</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/a205da303f63160c9a0ca.png"></p>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo-log"></a>undo-log</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">undo log主要有两个作用：</span><br><span class="line">当事务回滚时用于将数据恢复到修改前的样子</span><br><span class="line">另一个作用是MVCC ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过undo log 读取之前的版本数据，以此实现非锁定读</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 InnoDB 存储引擎中 undo log 分为两种：insert undo log 和 update undo log：</span><br><span class="line">insert undo log：指在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对其他事务不可见，故该 undo log 可以在事务提交后直接删除。不需要进行 purge 操作</span><br><span class="line">insert 时的数据初始状态：</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/9cf0449f3ad9b65edc151.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update undo log：update 或 delete 操作中产生的 undo log。该 undo log可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。提交时放入 undo log 链表，等待 purge线程 进行最后的删除</span><br><span class="line">数据第一次被修改时：</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/6caae7a0439123b9a032c.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据第二次被修改时：</span><br></pre></td></tr></table></figure>

<p><img src="https://telegraph-image-5ol.pages.dev/file/53ee0b67407e360a9afd1.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不同事务或者相同事务的对同一记录行的修改，会使该记录行的 undo log 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录。</span><br></pre></td></tr></table></figure>

<h4 id="数据可见性算法"><a href="#数据可见性算法" class="headerlink" title="数据可见性算法"></a>数据可见性算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 InnoDB 存储引擎中，创建一个新事务后，执行每个select 语句前都会创建一个快照（Read View），**快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号**。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，InnoDB 会将该记录行的 DB_TRX_ID 与 Read View 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</span><br></pre></td></tr></table></figure>

<h3 id="RC-和-RR-隔离级别下-MVCC-的差异"><a href="#RC-和-RR-隔离级别下-MVCC-的差异" class="headerlink" title="RC 和 RR 隔离级别下 MVCC 的差异"></a>RC 和 RR 隔离级别下 MVCC 的差异</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在事务隔离级别 RC 和 RR （InnoDB 存储引擎的默认事务隔离级别）下，InnoDB 存储引擎使用 MVCC（非锁定一致性读），但它们生成 Read View 的时机却不同</span><br><span class="line">在 RC 隔离级别下的 **每次select** 查询前都生成一个Read <span class="title function_">View</span> <span class="params">(m_ids 列表)</span></span><br><span class="line">在 RR 隔离级别下只在事务开始后 **第一次select** 数据前生成一个Read View（m_ids 列表）</span><br></pre></td></tr></table></figure>

<h3 id="MVCC-解决不可重复读问题"><a href="#MVCC-解决不可重复读问题" class="headerlink" title="MVCC 解决不可重复读问题"></a>MVCC 解决不可重复读问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虽然RC和RR都通过MVCC来读取快照数据，但由于生成Read View时机不同，从而在RR级别下实现可重复读</span><br><span class="line">总结： 在RC隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读</span><br></pre></td></tr></table></figure>

<h3 id="MVCC➕Next-key-Lock-防止幻读"><a href="#MVCC➕Next-key-Lock-防止幻读" class="headerlink" title="MVCC➕Next-key-Lock 防止幻读"></a>MVCC➕Next-key-Lock 防止幻读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InnoDB存储引擎在 RR 级别下通过 MVCC和 Next-key Lock 来解决幻读问题：</span><br><span class="line">**<span class="number">1</span>、执行普通 select，此时会以 MVCC 快照读的方式读取数据**</span><br><span class="line">在快照读的情况下，RR隔离级别只会在事务开启后的第一次查询生成Read View ，并使用至事务提交。所以在生成Read View之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</span><br><span class="line"></span><br><span class="line">**<span class="number">2</span>、执行 select...<span class="keyword">for</span> update/lock in share mode、insert、update、delete 等当前读**</span><br><span class="line">在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lock来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</span><br></pre></td></tr></table></figure>

<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h2 id="SQL-语句在-MySQL-中的执行过程"><a href="#SQL-语句在-MySQL-中的执行过程" class="headerlink" title="SQL 语句在 MySQL 中的执行过程"></a>SQL 语句在 MySQL 中的执行过程</h2><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/25/redis/" title="redis"><img class="cover" src="https://telegraph-image-5ol.pages.dev/file/8a3c1e050eaec49f1e7f3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">redis</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/15/%E9%9F%B3%E4%B9%90/" title="音乐"><img class="cover" src="https://telegraph-image-5ol.pages.dev/file/b1d43ca4dc69e9e978992.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">音乐</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://telegraph-image-5ol.pages.dev/file/41ea36a938166256d6bc8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Kellercpv</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql"><span class="toc-number">1.</span> <span class="toc-text">mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM-%E5%92%8C-InnoDB-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">MyISAM 和 InnoDB 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">索引底层数据结构选型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash-%E8%A1%A8"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Hash 表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">二叉查找树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AVL-%E6%A0%91"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">AVL 树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91%E5%92%8C-B-%E6%A0%91"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">B 树和 B+ 树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%E5%92%8C-B-%E6%A0%91%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.1.5.1.</span> <span class="toc-text">B 树和 B+ 树区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">非聚簇索引和聚簇索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.2.</span> <span class="toc-text">索引类型总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">数据结构划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">底层存储方式划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%BB%B4%E5%BA%A6%E5%88%92%E5%88%86"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">应用维度划分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">主键索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">二级索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.5.</span> <span class="toc-text">聚簇索引与非聚簇索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">聚簇索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.5.1.1.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">非聚簇索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">1.2.5.2.1.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">非聚簇索引一定回表查询吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.6.</span> <span class="toc-text">覆盖索引和联合索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">最左匹配原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">1.2.7.</span> <span class="toc-text">索引下推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.2.8.</span> <span class="toc-text">正确使用索引的一些建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8A%A0%E5%9C%A8%E7%B4%A2%E5%BC%95%E4%B8%8A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3"><span class="toc-number">1.2.9.</span> <span class="toc-text">锁加在索引上如何理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">1.3.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log"><span class="toc-number">1.3.1.</span> <span class="toc-text">redo log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">刷盘时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">日志文件组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">redo log 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bin-log"><span class="toc-number">1.3.2.</span> <span class="toc-text">bin log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog-%E5%88%B0%E5%BA%95%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%9F"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">binlog 到底是用来干嘛的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">记录格式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#statement"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">statement</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#row"><span class="toc-number">1.3.2.2.2.</span> <span class="toc-text">row</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mixed"><span class="toc-number">1.3.2.2.3.</span> <span class="toc-text">mixed</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">写入机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">1.3.3.</span> <span class="toc-text">两阶段提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Undo-log"><span class="toc-number">1.3.4.</span> <span class="toc-text">Undo log</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.1.</span> <span class="toc-text">四大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.2.</span> <span class="toc-text">并发事务带来什么问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%8F%E8%AF%BB"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">脏读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">丢失修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">不可重复读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">幻读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">不可重复读和幻读有什么区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.4.3.</span> <span class="toc-text">并发事务的控制方式有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.4.4.</span> <span class="toc-text">事务隔离级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81-1"><span class="toc-number">1.5.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">1.5.1.</span> <span class="toc-text">表级锁和行级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.5.2.</span> <span class="toc-text">行级锁的使用有什么注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.3.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.4.</span> <span class="toc-text">行锁分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="toc-number">1.5.5.</span> <span class="toc-text">共享锁和排他锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-1"><span class="toc-number">1.5.6.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">1.5.7.</span> <span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E9%94%81"><span class="toc-number">1.5.8.</span> <span class="toc-text">自增锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-number">1.5.9.</span> <span class="toc-text">当前读和快照读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC"><span class="toc-number">1.6.</span> <span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.1.</span> <span class="toc-text">多版本并发控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB%E5%92%8C%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-number">1.6.2.</span> <span class="toc-text">一致性非锁定读和锁定读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">一致性非锁定读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">锁定读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E5%AF%B9-MVCC-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.3.</span> <span class="toc-text">InnoDB 对 MVCC 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">隐藏字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReadView"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">ReadView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">undo-log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%81%E6%80%A7%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">数据可见性算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RC-%E5%92%8C-RR-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B-MVCC-%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">1.6.4.</span> <span class="toc-text">RC 和 RR 隔离级别下 MVCC 的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC-%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.5.</span> <span class="toc-text">MVCC 解决不可重复读问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E2%9E%95Next-key-Lock-%E9%98%B2%E6%AD%A2%E5%B9%BB%E8%AF%BB"><span class="toc-number">1.6.6.</span> <span class="toc-text">MVCC➕Next-key-Lock 防止幻读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">锁优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E8%AF%AD%E5%8F%A5%E5%9C%A8-MySQL-%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.8.</span> <span class="toc-text">SQL 语句在 MySQL 中的执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.9.</span> <span class="toc-text">性能优化</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/10/%E8%AE%A1%E7%BD%91/" title="无题">无题</a><time datetime="2024-03-10T07:51:19.396Z" title="发表于 2024-03-10 15:51:19">2024-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/25/redis/" title="redis"><img src="https://telegraph-image-5ol.pages.dev/file/8a3c1e050eaec49f1e7f3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis"/></a><div class="content"><a class="title" href="/2023/12/25/redis/" title="redis">redis</a><time datetime="2023-12-24T16:00:00.000Z" title="发表于 2023-12-25 00:00:00">2023-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/21/mysql/" title="mysql"><img src="https://telegraph-image-5ol.pages.dev/file/b1d43ca4dc69e9e978992.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql"/></a><div class="content"><a class="title" href="/2023/12/21/mysql/" title="mysql">mysql</a><time datetime="2023-12-20T16:00:00.000Z" title="发表于 2023-12-21 00:00:00">2023-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/15/%E9%9F%B3%E4%B9%90/" title="音乐"><img src="https://telegraph-image-5ol.pages.dev/file/b1d43ca4dc69e9e978992.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="音乐"/></a><div class="content"><a class="title" href="/2023/12/15/%E9%9F%B3%E4%B9%90/" title="音乐">音乐</a><time datetime="2023-12-14T16:00:00.000Z" title="发表于 2023-12-15 00:00:00">2023-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/15/%E8%A7%86%E9%A2%91/" title="视频"><img src="https://telegraph-image-5ol.pages.dev/file/8a3c1e050eaec49f1e7f3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="视频"/></a><div class="content"><a class="title" href="/2023/12/15/%E8%A7%86%E9%A2%91/" title="视频">视频</a><time datetime="2023-12-14T16:00:00.000Z" title="发表于 2023-12-15 00:00:00">2023-12-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Kellercpv</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>