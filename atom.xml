<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-10T07:59:32.895Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Kellercpv</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://example.com/2024/01/15/%E8%AE%A1%E7%BD%91/"/>
    <id>http://example.com/2024/01/15/%E8%AE%A1%E7%BD%91/</id>
    <published>2024-01-14T16:00:00.000Z</published>
    <updated>2024-03-10T07:59:32.895Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="计网基础"><a href="#计网基础" class="headerlink" title="计网基础"></a>计网基础</h2><h3 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OSI分层：七层模型：</span><br><span class="line"><span class="number">1</span>、应用层，表示层，会话层，传输层，网络层，数据链路层，物理层</span><br><span class="line">TCP/IP模型：四层模型（实际应用，教科书是五层）：</span><br><span class="line"><span class="number">1</span>、应用层，传输层，网络层，网络接口层</span><br><span class="line">TCP/IP模型：五层模型</span><br><span class="line"><span class="number">1</span>、应用层，传输层，网络层，数据链路层，物理层</span><br></pre></td></tr></table></figure><h3 id="各层网络协议"><a href="#各层网络协议" class="headerlink" title="各层网络协议"></a>各层网络协议</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、应用层：HTTP，DNS，FTP，SMTP，SSH</span><br><span class="line"><span class="number">2</span>、传输层，TCP，UDP</span><br><span class="line"><span class="number">3</span>、网络层：IP，ARP，NAT</span><br><span class="line"><span class="number">4</span>、网络接口层：</span><br></pre></td></tr></table></figure><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="输入-URL-到页面展示过程"><a href="#输入-URL-到页面展示过程" class="headerlink" title="输入 URL 到页面展示过程"></a>输入 URL 到页面展示过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 浏览器接收到⽤户请求，先检查浏览器缓存⾥是否有缓存该资源，如果有直接返回；如果没有进⼊下⼀步⽹络请求。 </span><br><span class="line"><span class="number">2.</span> ⽹络请求前，进⾏ **DNS**解析 ，以获取请求域名的 IP地址 。如果请求协议是 HTTPS ，那么还需要 建⽴TLS连接 。DNS解析时会按本地浏览器缓存-&gt;本地 Host ⽂件-&gt;路由器缓存-&gt; DNS 服务器-&gt;根 DNS 服务器的顺序查询域名对应 IP ，直到找到为⽌。 </span><br><span class="line"><span class="number">3.</span> 浏览器与服务器IP建⽴TCP连接。连接建⽴后，浏览器端会构建请求⾏、请求头等信息，并把和该域名 相关的 Cookie 等数据附加到请求头中，向服务器构建请求信息。 </span><br><span class="line"><span class="number">4.</span> 服务器接收到请求信息，根据请求⽣成响应数据。 </span><br><span class="line"><span class="number">5.</span> 浏览器解析响应头。若响应头状态码为 <span class="number">301</span>、<span class="number">302</span> ，会重定向到新地址；若响应数据类型是字节流类 型，⼀般会将请求提交给下载管理器；若是HTML类型，会进⼊下⼀部渲染流程。 </span><br><span class="line"><span class="number">6.</span> 浏览器解析 HTML ⽂件，创建 DOM 树，解析 CSS 进⾏样式计算，然后将CSS和DOM合并，构建渲染树；最后布局和绘制渲染树，完成⻚⾯展示。</span><br></pre></td></tr></table></figure><h3 id="HTTPS-和-HTTP-区别"><a href="#HTTPS-和-HTTP-区别" class="headerlink" title="HTTPS 和 HTTP 区别"></a>HTTPS 和 HTTP 区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP 是明⽂传输，⽽HTTPS 通过 SSL\TLS进⾏了加密 </span><br><span class="line">HTTP 的端⼝号是 <span class="number">80</span>，HTTPS 是 <span class="number">443</span> </span><br><span class="line">HTTPS 需要到 CA 申请证书 </span><br><span class="line">HTTP 的连接简单，是⽆状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进⾏加密传输、身份认证的⽹络协议，⽐ HTTP 协议安全。</span><br></pre></td></tr></table></figure><h3 id="HTTP1-0-和-HTTP1-1-区别"><a href="#HTTP1-0-和-HTTP1-1-区别" class="headerlink" title="HTTP1.0 和 HTTP1.1 区别"></a>HTTP1.0 和 HTTP1.1 区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> ⻓连接 </span><br><span class="line">HTTP1<span class="number">.1</span> ⽀持⻓连接，每⼀个TCP连接上可以传送多个HTTP请求和响应，默认开启 Connection:Keep-Alive </span><br><span class="line">HTTP1<span class="number">.0</span> 默认为短连接，每次请求都需要建⽴⼀个TCP连接。 </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 缓存 </span><br><span class="line">HTTP1<span class="number">.0</span> 主要使⽤ If-Modified-Since/Expires 来做为缓存判断的标准 </span><br><span class="line">HTTP1<span class="number">.1</span> 则引⼊了更多的缓存控制策略例如Entity tag /If-None-Match等更多可供选择的缓存头来控制缓存策略。 </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 管道化 </span><br><span class="line">基于 HTTP1<span class="number">.1</span> 的⻓连接，使得请求管线化成为可能。管线化使得请求能够“并⾏”传输，但是响应必须按照请求发出的顺序依次返回，性能在⼀定程度上得到了改善。 </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 增加Host字段 </span><br><span class="line">使得⼀个服务器能够⽤来创建多个 Web 站点。 </span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 状态码 </span><br><span class="line">新增了<span class="number">24</span>个错误状态响应码 </span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 带宽优化 </span><br><span class="line">HTTP1<span class="number">.0</span> 中，存在⼀些浪费带宽的现象，例如客户端只是需要某个对象的⼀部分，⽽服务器却将整个对象送过来了，并且不⽀持断点续传功能 </span><br><span class="line">HTTP1<span class="number">.1</span> 则在请求头引⼊了 range头域，它允许只请求资源的某个部分，即返回码是 <span class="number">206</span>（Partial Content）</span><br></pre></td></tr></table></figure><h3 id="HTTP1-1-和-HTTP2-0-区别"><a href="#HTTP1-1-和-HTTP2-0-区别" class="headerlink" title="HTTP1.1 和 HTTP2.0 区别"></a>HTTP1.1 和 HTTP2.0 区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> ⼆进制分帧 </span><br><span class="line">在应⽤层 （HTTP/<span class="number">2.0</span>） 和传输层 （TCP or UDP） 之间增加⼀个⼆进制分帧层，从⽽突破 HTTP1<span class="number">.1</span> 的性能限制，改进传输性能，实现低延迟和⾼吞吐量。 </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 多路复⽤（MultiPlexing） </span><br><span class="line">允许同时通过单⼀的 HTTP/<span class="number">2</span> 连接发起多重的请求-响应消息，这个强⼤的功能则是基于“⼆进制分帧”的特性。 </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> ⾸部压缩 </span><br><span class="line">HTTP1<span class="number">.1</span> 不⽀持 header数据的压缩， HTTP/<span class="number">2.0</span> 使⽤ HPACK 算法对 header的数据进⾏压缩，这样数据体积⼩了，在⽹络上传输就会更快。⾼效的压缩算法可以很⼤的压缩header ，减少发送包的数量从⽽降低延迟。 </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 服务端推送 （server push） </span><br><span class="line">在 HTTP/<span class="number">2</span>中，服务器可以对客户端的⼀个请求发送多个响应，即服务器可以额外的向客户端推送资源，⽽⽆需客户端明确的请求。</span><br></pre></td></tr></table></figure><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DNS解析过程：</span><br><span class="line"><span class="number">1</span>、浏览器缓存有没有映射</span><br><span class="line"><span class="number">2</span>、本地Host文件有没有映射</span><br><span class="line"><span class="number">3</span>、本地DNS服务器有没有映射</span><br><span class="line"><span class="number">4</span>、根域名服务器返回顶级域名服务器ip给本地服务器</span><br><span class="line"><span class="number">5</span>、顶级域名服务器返回权威域名服务器ip给本地服务器</span><br><span class="line"><span class="number">6</span>、权威域名服务器返回具体ip给本地服务器</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">详细版：</span><br><span class="line"><span class="number">1.</span> ⾸先⽤户在浏览器输⼊URL地址后，会先查询浏览器缓存是否有该域名对应的IP地址。 </span><br><span class="line"><span class="number">2.</span> 如果浏览器缓存中没有，会去计算机本地的Host⽂件中查询是否有对应的缓存。 </span><br><span class="line"><span class="number">3.</span> 如果Host⽂件中也没有则会向本地的DNS解析器（通常由你的互联⽹服务提供商（ISP）提供）发送⼀个DNS查询请求。 </span><br><span class="line"><span class="number">4.</span> 如果本地DNS解析器没有缓存该域名的解析记录，它会向根DNS服务器发出查询请求。根DNS服务器并不负责解析域名，但它能告诉本地DNS解析器应该向哪个顶级域（.com/.net/.org）的DNS服务器继续查询。 </span><br><span class="line"><span class="number">5.</span> 本地DNS解析器接着向指定的顶级域DNS服务器发出查询请求。顶级域DNS服务器也不负责具体的域名解析，但它能告诉本地DNS解析器应该前往哪个权威DNS服务器查询下⼀步的信息。 </span><br><span class="line"><span class="number">6.</span> 本地DNS解析器最后向权威DNS服务器发送查询请求。 权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求时，它会查找<span class="string">&quot;example.com&quot;</span>域名对应的IP地址，并将结果返回给本地DNS解析器。 </span><br><span class="line"><span class="number">7.</span> 本地DNS解析器将收到的IP地址返回给浏览器，并且还会将域名解析结果缓存在本地，以便下次访问时更快地响应。</span><br></pre></td></tr></table></figure><h2 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h2><h3 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">标准：记忆可以分为<span class="number">1</span>、面向，可不可靠，传递形式，是否有状态，传输效率，通信双发，应用场景</span><br><span class="line"><span class="number">1</span>、TCP是面向链接，而UDP不面向链接，即TCP在发送数据前会用三次握手建立链接</span><br><span class="line"><span class="number">2</span>、TCP提供可靠传输，UDP不提供可靠传输，即TCP在传输数据之前会用三次握手建立链接，在传输数据时有确认，窗口，重传，拥塞控制机制。UDP不保证数据是否到达和到达的顺序。</span><br><span class="line"><span class="number">3</span>、TCP面向字节流的，UDP面向报文。</span><br><span class="line"><span class="number">4</span>、TCP传输是有状态的，TCP会记录自己发送消息的状态比如消息是否发送，消息是否被接受等，而UDP是无状态的</span><br><span class="line"><span class="number">5</span>、TCP因为有链接，确认重传机制传递效率比UDP低。</span><br><span class="line"><span class="number">6</span>、TCP首部是<span class="number">20</span>字节，UDP首部是<span class="number">8</span>字节</span><br><span class="line"><span class="number">7</span>、TCP只能点到点通信，UDP支持一对一，一对多，多对多通信</span><br><span class="line"><span class="number">8</span>、TCP常用于要求通信数据可靠的场景，UDP常用要求通信速度的场景。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">分开记忆：面向，可不可靠，传输形式，状态，效率，首部，通信方式，应用场景</span><br><span class="line">TCP</span><br><span class="line"><span class="number">1</span>、TCP是面向连接的</span><br><span class="line"><span class="number">2</span>、TCP提供可靠传输</span><br><span class="line"><span class="number">3</span>、TCP面向字节流</span><br><span class="line"><span class="number">4</span>、TCP有状态</span><br><span class="line"><span class="number">5</span>、TCP传输效率低</span><br><span class="line"><span class="number">6</span>、TCP首部大（<span class="number">20</span>-<span class="number">60</span>字节）</span><br><span class="line"><span class="number">7</span>、TCP只支持点到点通信</span><br><span class="line"><span class="number">8</span>、TCP常用于要求通信数据可靠的场景</span><br><span class="line"></span><br><span class="line">UDP：</span><br><span class="line"><span class="number">1</span>、UDP不面向链接</span><br><span class="line"><span class="number">2</span>、UDP不提供可靠传输</span><br><span class="line"><span class="number">3</span>、UDP面向报文（传输形式）</span><br><span class="line"><span class="number">4</span>、UDP是无状态的</span><br><span class="line"><span class="number">5</span>、UDP传输效率高</span><br><span class="line"><span class="number">6</span>、UDP首部小（<span class="number">8</span>字节）</span><br><span class="line"><span class="number">7</span>、UDP支持一对一，一对多，多对多</span><br><span class="line"><span class="number">8</span>、UDP常用于要求通信速度的场景</span><br></pre></td></tr></table></figure><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三次握⼿的过程如下： </span><br><span class="line"><span class="number">1.</span> 客户端向服务器发送 SYN 报⽂、初始化序列号 seq=x</span><br><span class="line"><span class="number">2.</span> 服务端向客户端发送 ACK 和 SYN 报⽂（ACK = x+<span class="number">1</span>，seq=y）</span><br><span class="line"><span class="number">3.</span> 客户端向服务端发送 ACK（ACK=y+<span class="number">1</span>）</span><br></pre></td></tr></table></figure><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手?"></a>为什么要三次握手?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</span><br><span class="line">**第一次握手**：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</span><br><span class="line">**第二次握手**：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</span><br><span class="line">**第三次握手**：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</span><br><span class="line">三次握手就能确认双方收发功能都正常，缺一不可。</span><br></pre></td></tr></table></figure><h3 id="第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。</span><br></pre></td></tr></table></figure><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一次挥手：客户端发送一个 FIN（SEQ=x） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后客户端进入FIN-WAIT-<span class="number">1</span>状态。</span><br><span class="line">第二次挥手：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+<span class="number">1</span>）标志的数据包-&gt;客户端 。然后服务端进入 CLOSE-WAIT状态，客户端进入FIN-WAIT-<span class="number">2</span>状态。</span><br><span class="line">第三次挥手：服务端发送一个FIN (SEQ=y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入LAST-ACK状态。</span><br><span class="line">第四次挥手：客户端发送 ACK (ACK=y+<span class="number">1</span>)标志的数据包-&gt;服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+<span class="number">1</span>)标志的数据包后进入 CLOSE 状态。此时如果客户端等待2MSL后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</span><br><span class="line">只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/a1f1c386aaca59d9911e8.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简化版：</span><br><span class="line">第一次挥手：客户端向服务端发送FIN数据包，初始化序列号SEQ=x</span><br><span class="line">第二次挥手：服务端向客户端发送ACK（ack=x+<span class="number">1</span>）</span><br><span class="line">第三次挥手：服务端向客户端发送FIN数据包，SEQ=y</span><br><span class="line">第四次挥手：客户端向服务端发送ACK(ack=y+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</span><br></pre></td></tr></table></figure><h4 id="为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？"><a href="#为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？" class="headerlink" title="为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？"></a>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</span><br></pre></td></tr></table></figure><h4 id="如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？" class="headerlink" title="如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？"></a>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端没有收到 ACK 确认，会重新发送 FIN 请求。</span><br></pre></td></tr></table></figure><h4 id="为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><a href="#为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？" class="headerlink" title="为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"></a>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 <span class="number">2</span>*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</span><br></pre></td></tr></table></figure><h3 id="TCP-如何保证可靠传输"><a href="#TCP-如何保证可靠传输" class="headerlink" title="TCP 如何保证可靠传输"></a>TCP 如何保证可靠传输</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">基于数据块传输：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</span><br><span class="line">对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</span><br><span class="line">校验和: TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</span><br><span class="line">超时重传: 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。</span><br><span class="line">流量控制: TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</span><br><span class="line">拥塞控制 : 当网络拥塞时，减少数据的发送</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简化版：</span><br><span class="line"><span class="number">1</span>、确认和重传</span><br><span class="line"><span class="number">2</span>、窗口</span><br><span class="line"><span class="number">3</span>、拥塞控制</span><br><span class="line"><span class="number">4</span>、校验和</span><br></pre></td></tr></table></figure><h3 id="TCP-如何实现流量控制"><a href="#TCP-如何实现流量控制" class="headerlink" title="TCP 如何实现流量控制"></a>TCP 如何实现流量控制</h3><h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><h3 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h3><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h2 id="ARP-和-NAT"><a href="#ARP-和-NAT" class="headerlink" title="ARP 和 NAT"></a>ARP 和 NAT</h2><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网络地址转换，应用于内部网到外部网的地址转换过程中。</span><br></pre></td></tr></table></figure><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARP 协议，全称地址解析协议，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://example.com/2023/12/25/redis/"/>
    <id>http://example.com/2023/12/25/redis/</id>
    <published>2023-12-24T16:00:00.000Z</published>
    <updated>2024-03-10T07:41:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String：简单动态字符串</span><br><span class="line">    </span><br><span class="line">List：双向链表或压缩列表；</span><br><span class="line">如果列表元素个数小于<span class="number">512</span>，列表每个元素大小小于<span class="number">64</span>字节，使用压缩列表作为底层数据结构，否则使用双向链表作为底层数据结构。</span><br><span class="line">Redis3<span class="number">.2</span>版本以后，List底层数据结构只使用quicklist，替代双向链表和压缩列表 </span><br><span class="line">    </span><br><span class="line">Hash：压缩列表或哈希表；</span><br><span class="line">如果哈希类型元素个数小于<span class="number">512</span>个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于<span class="number">64</span>字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis会使用压缩列表作为Hash类型的底层数据结构；</span><br><span class="line">如果哈希类型元素不满足上面条件，Redis会使用哈希表作为Hash类型的底层数据结构。</span><br><span class="line">在 Redis <span class="number">7.0</span> 中，压缩列表数据结构已经废弃了，交由listpack数据结构来实现了。</span><br><span class="line">    </span><br><span class="line">Set 类型的底层数据结构是由哈希表或整数集合实现的：</span><br><span class="line">如果集合中的元素都是整数且元素个数小于<span class="number">512</span>（默认值，set-maxintset-entries配置）个，Redis会使用整数集合作为Set类型的底层数据结构；</span><br><span class="line">如果集合中的元素不满足上面条件，则Redis使用哈希表作为Set类型的底层数据结构。</span><br><span class="line">    </span><br><span class="line">Zset 类型的底层数据结构是由压缩列表或跳表实现的：</span><br><span class="line">如果有序集合的元素个数小于<span class="number">128</span>个，并且每个元素的值小于<span class="number">64</span>字节时，Redis会使用压缩列表作为Zset类型的底层数据结构；</span><br><span class="line">如果有序集合的元素不满足上面的条件，Redis会使用跳表作为Zset类型的底层数据结构；</span><br><span class="line">在 Redis <span class="number">7.0</span> 中，压缩列表数据结构已经废弃了，交由listpack数据结构来实现了。</span><br></pre></td></tr></table></figure><h3 id="数据类型详解"><a href="#数据类型详解" class="headerlink" title="数据类型详解"></a>数据类型详解</h3><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis的持久化分为AOF日志和RDB快照</span><br><span class="line">    </span><br><span class="line">RDB快照就像照相，记录某一时刻redis数据库中的数据，分为全量快照和增量快照，快照的优点是恢复数据快。</span><br><span class="line">AOF日志是写后日志，先保存数据再记录日志，所以日志命令不会错误。</span><br><span class="line">redis采用混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。结合两种技术优点</span><br></pre></td></tr></table></figure><h3 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h3><h4 id="写回策略"><a href="#写回策略" class="headerlink" title="写回策略"></a>写回策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</span><br><span class="line">Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</span><br><span class="line">No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/8885a6bcecf68f3bd9b4c.png"></p><h4 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AOF 文件会越来越大,会造成以下问题：</span><br><span class="line">    一是，文件系统本身对文件大小有限制，无法保存过大的文件；</span><br><span class="line">    二是，如果文件太大，之后再往里面追加命令记录的话，效率也会变低；</span><br><span class="line">    三是，如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。</span><br><span class="line">    </span><br><span class="line">AOF重写就是解决这个问题，重写机制具有“多变一”功能。也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/bf407d50292470cf01062.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当我们对一个列表先后做了 <span class="number">6</span> 次修改操作后，列表的最后状态是[“D”, “C”, “N”]，</span><br><span class="line">此时，只用 LPUSH u:list “N”, “C”, <span class="string">&quot;D&quot;</span>这一条命令就能实现该数据的恢复，这就节省了五条命令的空间。对于被修改过成百上千次的键值对来说，重写能节省的空间当然就更大了。</span><br></pre></td></tr></table></figure><h4 id="AOF-重写过程"><a href="#AOF-重写过程" class="headerlink" title="AOF 重写过程"></a>AOF 重写过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重写的过程总结为“一个拷贝，两处日志”。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/26854b3f22f028a0a1bdd.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</span><br><span class="line">两处日志：因为主线程未阻塞，仍然可以处理新来的操作。两处日志都记录最新操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。</span><br></pre></td></tr></table></figure><h3 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快照是内存中的数据在某一个时刻的状态记录。AOF日志恢复数据需要逐一执行操作日志，恢复速度慢，而RDB快照在恢复数据时只需要读入内存即可恢复数据，恢复数据速度快。</span><br></pre></td></tr></table></figure><h4 id="快照执行过程"><a href="#快照执行过程" class="headerlink" title="快照执行过程"></a>快照执行过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis采用写时复制技术，避免在执行快照系统不能执行写操作。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/daf6530783f8edbd4a292.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享(不是复制)主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。</span><br><span class="line">    </span><br><span class="line">此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据(旧的)就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本</span><br><span class="line">数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</span><br></pre></td></tr></table></figure><h4 id="增量快照"><a href="#增量快照" class="headerlink" title="增量快照"></a>增量快照</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为增量快照需要记录全量快照后改变数据，这样需要存储大量的键值对，这样会消耗大量内存，有些得不偿失。</span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩的问题。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/d6b2b7de3374fc3962d25.png"></p><h4 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 均匀设置过期时间</span><br><span class="line">目的是为了不要让大量数据同时过期。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 互斥锁</span><br><span class="line">目的是减少访问数据库的请求。    </span><br><span class="line">当业务线程在处理用户请求时，如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。这样后面请求继续访问这个数据时就不会访问数据库了。</span><br><span class="line">实现互斥锁的时候，最好设置超时时间，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 后台更新缓存</span><br><span class="line">redis数据不设置过期时间，这样就不会造成缓存雪崩。更新缓存的工作交给后端线程定时更新。虽然数据没有过期时间但在内存不足时数据会被淘汰，所以当业务线程发现数据不存在时，使用MQ发送消息通知后台进程更新数据。</span><br></pre></td></tr></table></figure><h4 id="Redis-故障宕机"><a href="#Redis-故障宕机" class="headerlink" title="Redis 故障宕机"></a>Redis 故障宕机</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 服务熔断或请求限流机制（事情发生后的措施）</span><br><span class="line">服务熔断是暂停业务对redis的访问，避免大量请求访问数据库导致缓存雪崩等redis恢复后取消服务熔断。但这样会导致业务功能在熔断期间完全不可用。</span><br><span class="line">请求限流是只允许少量请求访问redis，这样只会有少量请求访问数据库，不会造成缓存雪崩，同时减少了对业务的影响。    </span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 构建 Redis 缓存高可靠集群</span><br><span class="line">减少Redis宕机</span><br></pre></td></tr></table></figure><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/cab516c60d1890de4127a.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。这样后面请求继续访问这个数据时就不会访问数据库了。</span><br><span class="line"><span class="number">2</span>、不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</span><br></pre></td></tr></table></figure><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/e011d3c17f23166bc93e0.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应对缓存穿透的方案，常见的方案有三种。</span><br><span class="line">第一种方案，非法请求的限制；</span><br><span class="line">第二种方案，缓存空值或者默认值；</span><br><span class="line">第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；</span><br><span class="line">查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据。</span><br></pre></td></tr></table></figure><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">引入redis后，如何保证redis和数据库的数据一致呢？</span><br><span class="line">    </span><br><span class="line">解决方案：先更新数据库，再删除缓存</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/47518c9ebbc5aa69a8d41.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，但是在实际中，这个问题出现的概率并不高。</span><br><span class="line">因为缓存的写入通常要远远快于数据库的写入,所以先更新数据库再删除缓存是可以保证数据一致性的。</span><br></pre></td></tr></table></figure><h2 id="内存淘汰策略和过期删除策略"><a href="#内存淘汰策略和过期删除策略" class="headerlink" title="内存淘汰策略和过期删除策略"></a>内存淘汰策略和过期删除策略</h2><h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><h4 id="如何判断-key-已经过期"><a href="#如何判断-key-已经过期" class="headerlink" title="如何判断 key 已经过期"></a>如何判断 key 已经过期</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在给key设置过期时间时，Redis会把key存到过期字典中，访问key时查找过期字典即可知道有没有过期。</span><br></pre></td></tr></table></figure><h4 id="过期键判断流程"><a href="#过期键判断流程" class="headerlink" title="过期键判断流程"></a>过期键判断流程</h4><p><img src="https://telegraph-image-5ol.pages.dev/file/0484d0199aba81b7da6e3.png"></p><h4 id="有哪些过期删除策略"><a href="#有哪些过期删除策略" class="headerlink" title="有哪些过期删除策略"></a>有哪些过期删除策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">过期键值删除策略的作用是将已过期的键值对删除。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">定时删除:</span><br><span class="line">在设置key过期时间时，同时创建一个定时事件，由事件处理器自动执行key的删除操作。</span><br><span class="line">优点：可以保证过期的key很快被释放，也就是内存可以尽快被释放，内存友好型。</span><br><span class="line">缺点：删除过期key需要占据一定CPU时间，如果同时删除大量过期key，将耗费相当一部分CPU时间，CPU不友好型。</span><br><span class="line">    </span><br><span class="line">惰性删除:</span><br><span class="line">不主动删除key，每次访问key都检测key是否过期，如果过期则删除该key。</span><br><span class="line">优点：不主动删除过期key，占据cpu时间较少，CPU友好型</span><br><span class="line">缺点：过期key如果不访问将得不到释放，会一直占据内存空间，内存不友好型    </span><br><span class="line"></span><br><span class="line">定期删除:</span><br><span class="line">每隔一定时间随机从数据库中取出一定数量的key进行检查，删除过期的key。</span><br><span class="line">优点：通过限制删除操作的频率，减少对CPU的影响，同时可以删除部分过期key减少内存消耗，CPU中等内存中等型</span><br><span class="line">缺点：CPU资源消耗没有惰性删除小，内存清理方面没有定时删除好。</span><br><span class="line">     难以确定执行的频率，频率太高等于定时删除，频率太低等于惰性删除。</span><br></pre></td></tr></table></figure><h4 id="Redis-采用过期删除策略"><a href="#Redis-采用过期删除策略" class="headerlink" title="Redis 采用过期删除策略"></a>Redis 采用过期删除策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis 选择「惰性删除+定期删除」这两种策略配和使用。可以发现CPU资源是比内存空间珍贵的。</span><br></pre></td></tr></table></figure><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存淘汰策略是当Redis运行内存超过了Redis设置的最大内存之后，则会使用内存淘汰策略删除符合条件的key，保障Redis运行。</span><br></pre></td></tr></table></figure><h4 id="有哪些内存淘汰策略"><a href="#有哪些内存淘汰策略" class="headerlink" title="有哪些内存淘汰策略"></a>有哪些内存淘汰策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、不进行数据淘汰的策略</span><br><span class="line">noeviction（Redis3<span class="number">.0</span>之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>、进行数据淘汰的策略</span><br><span class="line">针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</span><br><span class="line"></span><br><span class="line">在设置了过期时间的数据中进行淘汰：</span><br><span class="line"><span class="keyword">volatile</span>-random：随机淘汰设置了过期时间的任意键值；</span><br><span class="line"><span class="keyword">volatile</span>-ttl：优先淘汰更早过期的键值。</span><br><span class="line"><span class="keyword">volatile</span>-lru（Redis3<span class="number">.0</span> 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</span><br><span class="line"><span class="keyword">volatile</span>-lfu（Redis <span class="number">4.0</span> 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</span><br><span class="line">    </span><br><span class="line">在所有数据范围内进行淘汰：</span><br><span class="line">allkeys-random：随机淘汰任意键值;</span><br><span class="line">allkeys-lru：淘汰整个键值中最久未使用的键值；</span><br><span class="line">allkeys-lfu（Redis <span class="number">4.0</span> 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</span><br></pre></td></tr></table></figure><h2 id="Redis-为什么这么快"><a href="#Redis-为什么这么快" class="headerlink" title="Redis 为什么这么快"></a>Redis 为什么这么快</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Redis 基于内存，内存的访问速度是磁盘的上千倍；</span><br><span class="line">Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用</span><br><span class="line">Redis 内置了多种优化过后的数据类型/结构实现，性能非常高。</span><br></pre></td></tr></table></figure><h2 id="为什么要用-Redis-为什么要用缓存"><a href="#为什么要用-Redis-为什么要用缓存" class="headerlink" title="为什么要用 Redis&#x2F;为什么要用缓存"></a>为什么要用 Redis&#x2F;为什么要用缓存</h2><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis是内存数据库，查询性能比MySQL高很多。如果用户请求的数据是高频数据并且不会经常改变，就可以把数据存入到缓存中，提高系统性能。</span><br></pre></td></tr></table></figure><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis的QPS是远远大于MySQL的，所以我们可以将部分数据从MySQL转移到缓存中，提高系统整体的并发。</span><br></pre></td></tr></table></figure><h2 id="Redis-应用"><a href="#Redis-应用" class="headerlink" title="Redis 应用"></a>Redis 应用</h2><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们都是基于Redissio实现分布式锁</span><br></pre></td></tr></table></figure><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般是通过Redis+Lua脚本的方式实现限流</span><br></pre></td></tr></table></figure><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis自带的List数据结构可以作为一个简单的队列使用。Redis5<span class="number">.0</span>增加了Stream类型的数据结构更加适合用来做消息队列。它比较类似于kafka，有主题和消费组的概念，支持消息持久化以及ACK机制。</span><br></pre></td></tr></table></figure><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redisson内置了延时队列（基于Sorted Set实现的）</span><br></pre></td></tr></table></figure><h3 id="分布式-Session"><a href="#分布式-Session" class="headerlink" title="分布式 Session"></a>分布式 Session</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">利用String或者hash数据类型保存Session数据，所有的服务器都可以访问。</span><br><span class="line">为什么所有服务器都可以访问呢，我的Session保存在这台服务器的Redis中，其他服务器能访问得到吗</span><br></pre></td></tr></table></figure><h3 id="统计活跃用户"><a href="#统计活跃用户" class="headerlink" title="统计活跃用户"></a>统计活跃用户</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过Bitmap统计活跃用户。</span><br></pre></td></tr></table></figure><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redis 中有一个叫做 Sorted Set 的数据类型经常被用在各种排行榜的场景。</span><br><span class="line">相关的一些 Redis 命令: ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。</span><br></pre></td></tr></table></figure><h2 id="Redis-做消息队列"><a href="#Redis-做消息队列" class="headerlink" title="Redis 做消息队列"></a>Redis 做消息队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。</span><br><span class="line"><span class="number">1</span>、使用List做消息队列，没有消息确认等机制，需要自己实现，消息丢失（客户端断开连接和Redis宕机都会导致消息丢失）、消息堆积（发布者发布的消息的时候不会管消费者具体能力如何）等问题没有一个比较好的解决方法。优点是实现简单。</span><br><span class="line"><span class="number">2</span>、使用Stream做消息队列，使用起来麻烦，并且虽然有消息确认机制，但Redis发生故障恢复后不能保证消息至少被消费一次。</span><br></pre></td></tr></table></figure><h3 id="List-实现"><a href="#List-实现" class="headerlink" title="List 实现"></a>List 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">通过 RPUSH/LPOP 或者 LPUSH/RPOP即可实现简易版消息队列：</span><br><span class="line">_# 生产者生产消息</span><br><span class="line">RPUSH myList msg1 <span class="title function_">msg2</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">2</span></span><br><span class="line">RPUSH myList <span class="title function_">msg3</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line"># 消费者消费消息</span><br><span class="line">LPOP myList</span><br><span class="line"><span class="string">&quot;msg1&quot;</span></span><br><span class="line">_</span><br><span class="line">不过，通过 RPUSH/LPOP 或者 LPUSH/RPOP这样的方式存在性能问题，我们需要不断轮询去调用 RPOP 或 LPOP 来消费消息。当List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。</span><br><span class="line">因此，Redis 还提供了 BLPOP、BRPOP 这种阻塞式读取的命令（带 B-Bloking 的都是阻塞式），并且还支持一个超时参数。如果List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后在返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 <span class="number">0</span> 时，即可无限等待，直到弹出消息</span><br><span class="line"></span><br><span class="line"># 超时时间为 10s</span><br><span class="line"># 如果有数据立刻返回，否则最多等待<span class="number">10</span>秒</span><br><span class="line">BRPOP myList <span class="number">10</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"></span><br><span class="line">**List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。**</span><br><span class="line">**Redis <span class="number">2.0</span> 引入了发布订阅 (pub/sub) 功能，解决了 List 实现消息队列没有广播机制的问题。**</span><br></pre></td></tr></table></figure><h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><h3 id="Redis-单线程模型"><a href="#Redis-单线程模型" class="headerlink" title="Redis 单线程模型"></a>Redis 单线程模型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单线程+IO多路复用</span><br><span class="line">Redis 通过 IO 多路复用程序 来监听来自客户端的大量连接</span><br><span class="line">I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">感觉这里说的有点模糊</span><br></pre></td></tr></table></figure><h3 id="Redis6-0-之前为什么不使用多线程"><a href="#Redis6-0-之前为什么不使用多线程" class="headerlink" title="Redis6.0 之前为什么不使用多线程"></a>Redis6.0 之前为什么不使用多线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**那 Redis6<span class="number">.0</span> 之前为什么不使用多线程？**</span><br><span class="line">单线程编程容易并且更容易维护；</span><br><span class="line">Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</span><br><span class="line">多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</span><br></pre></td></tr></table></figure><h2 id="Redis-性能优化"><a href="#Redis-性能优化" class="headerlink" title="Redis 性能优化"></a>Redis 性能优化</h2><h2 id="3-种缓存读写策略"><a href="#3-种缓存读写策略" class="headerlink" title="3 种缓存读写策略"></a>3 种缓存读写策略</h2><h3 id="旁路缓存模式"><a href="#旁路缓存模式" class="headerlink" title="旁路缓存模式"></a>旁路缓存模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">写：</span><br><span class="line">先更新 db</span><br><span class="line">然后直接删除 cache </span><br><span class="line"></span><br><span class="line">读 :</span><br><span class="line">从 cache 中读取数据，读取到就直接返回</span><br><span class="line">cache 中读取不到的话，就从 db 中读取数据返回</span><br><span class="line">再把数据放到 cache 中。</span><br></pre></td></tr></table></figure><h4 id="在写数据过程中可以先删除缓存再更新数据库吗"><a href="#在写数据过程中可以先删除缓存再更新数据库吗" class="headerlink" title="在写数据过程中可以先删除缓存再更新数据库吗"></a>在写数据过程中可以先删除缓存再更新数据库吗</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不行,可能会造成 数据库（db）和缓存（Cache）数据不一致的问题。</span><br><span class="line">A删缓存，B删缓存，B更新数据库，A更新数据库</span><br><span class="line">最后发现B操作丢失</span><br></pre></td></tr></table></figure><h4 id="先更新数据库，后删除缓存就没有问题了么"><a href="#先更新数据库，后删除缓存就没有问题了么" class="headerlink" title="先更新数据库，后删除缓存就没有问题了么"></a>先更新数据库，后删除缓存就没有问题了么</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多</span><br></pre></td></tr></table></figure><h4 id="旁路缓存缺陷"><a href="#旁路缓存缺陷" class="headerlink" title="旁路缓存缺陷"></a>旁路缓存缺陷</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**缺陷 <span class="number">1</span>：首次请求数据一定不在 cache 的问题**</span><br><span class="line">解决办法：可以将热点数据可以提前放入 cache 中。</span><br><span class="line">**缺陷 <span class="number">2</span>：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。**</span><br><span class="line">数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。</span><br><span class="line"></span><br><span class="line">可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</span><br></pre></td></tr></table></figure><h3 id="读写穿透"><a href="#读写穿透" class="headerlink" title="读写穿透"></a>读写穿透</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**写：**</span><br><span class="line">先查 cache，cache 中不存在，直接更新 db。</span><br><span class="line">cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（**同步更新 cache 和 db**）。</span><br><span class="line"></span><br><span class="line">读：</span><br><span class="line">从 cache 中读取数据，读取到就直接返回 。</span><br><span class="line">读取不到的话，先从 db 加载，写入到 cache 后返回响应。</span><br></pre></td></tr></table></figure><h3 id="异步缓存写入"><a href="#异步缓存写入" class="headerlink" title="异步缓存写入"></a>异步缓存写入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write Behind则是只更新缓存，不直接更新db，而是改为异步批量的方式来更新db。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://example.com/2023/12/21/mysql/"/>
    <id>http://example.com/2023/12/21/mysql/</id>
    <published>2023-12-20T16:00:00.000Z</published>
    <updated>2024-03-10T07:28:13.172Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="MyISAM-和-InnoDB-有什么区别？"><a href="#MyISAM-和-InnoDB-有什么区别？" class="headerlink" title="MyISAM 和 InnoDB 有什么区别？"></a>MyISAM 和 InnoDB 有什么区别？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MySQL5<span class="number">.5</span>之前默认引擎是MyISAM，现在是InnoDB。</span><br><span class="line">区别：</span><br><span class="line"><span class="number">1</span>、InnoDB支持行锁表锁，MyISAM只支持表锁</span><br><span class="line"><span class="number">2</span>、MyISAM不支持事务，InnoDB支持事务，并实现了SQL标准定义四个隔离级别</span><br><span class="line"><span class="number">3</span>、MyISAM不支持外键，InnoDB支持外键</span><br><span class="line"><span class="number">4</span>、MyISAM不支持MVCC，InnoDB支持MVCC</span><br><span class="line"><span class="number">5</span>、虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</span><br><span class="line"><span class="number">6</span>、MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</span><br><span class="line"><span class="number">7</span>、InnoDB 的性能比 MyISAM 更强大</span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</span><br><span class="line">索引底层数据结构存在很多种类型，常见的索引结构有：B树，B+树和Hash、红黑树。在MySQL中，无论是InnoDB还是MyISAM，都使用B+树作为索引结构。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line"><span class="number">1</span>、使用索引可以大大加快数据的检索速度（大大减少检索的数据量）</span><br><span class="line"><span class="number">2</span>、创建唯一索引，可以保证数据库表中每一行数据的唯一性。</span><br><span class="line">缺点：</span><br><span class="line"><span class="number">1</span>、创建索引和维护索引需要耗费许多时间，当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQl执行效率。</span><br><span class="line"><span class="number">2</span>、索引需要使用物理文件存储，也会耗费一定空间。</span><br></pre></td></tr></table></figure><h3 id="索引底层数据结构选型"><a href="#索引底层数据结构选型" class="headerlink" title="索引底层数据结构选型"></a>索引底层数据结构选型</h3><h4 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">哈希表可以通过hash算法，快速找到key对应index，即可快速取出对应的值。因此哈希表可以快速检索数据。</span><br><span class="line">哈希表这么快，为什么MySQL没有使用其作为索引的数据结构呢？</span><br><span class="line">主要是因为Hash索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那Hash索引可就不行了。并且每次IO只能取一个。</span><br><span class="line">SELECT * FROM tb1 WHERE id &lt; <span class="number">500</span>;</span><br><span class="line">在这种范围查询中，Hash索引需要把<span class="number">1</span>-<span class="number">499</span>的数据都进行一次hash计算定位数据。</span><br></pre></td></tr></table></figure><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二叉查找树具有以下特点：</span><br><span class="line">左子树所有节点的值均小于根节点的值。</span><br><span class="line">右子树所有节点的值均大于根节点的值。</span><br><span class="line">左右子树也分别为二叉查找树。</span><br><span class="line">当二叉查找树是平衡的时候，查询的时间复杂度为O（log2（N）），具有较高的效率。当二叉树不平衡时，最坏情况下，时间复杂度退化为O（N）。二叉查找树的性能非常依赖于他的平衡程度，所以不适合作为MySQL索引底层数据结构</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/842ee2bdba6bb32c5421b.png"></p><h4 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVL树是一种自平衡二叉查找树，AVL树的特点是保证任何结点的左右子树高度之差不超过<span class="number">1</span>，查找，插入，删除平均情况和最坏情况下的时间复杂度都是O（logn）</span><br><span class="line">缺点：</span><br><span class="line"><span class="number">1</span>、由于AVL树需要频繁的进行旋转操作来保持平衡，因此会有较大的计算开销降低了查询性能。</span><br><span class="line"><span class="number">2</span>、每个节点存储一个数据，每次磁盘IO时只能读取一个节点的数据，当需要查询的数据分布在多个节点上，那么就需要进行多次磁盘IO。</span><br><span class="line"></span><br><span class="line">磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。</span><br></pre></td></tr></table></figure><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，特点：</span><br><span class="line"><span class="number">1</span>、每个节点非红即黑；</span><br><span class="line"><span class="number">2</span>、根节点总是黑色的；</span><br><span class="line"><span class="number">3</span>、每个叶子节点都是黑色的空节点（NIL 节点）；</span><br><span class="line"><span class="number">4</span>、如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</span><br><span class="line"><span class="number">5</span>、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/e229e5273a256390b5c76.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">和AVL树不同，红黑树并不追求严格的平衡，而是大致的平衡。</span><br><span class="line">优点：</span><br><span class="line">红黑树插入和删除操作效率大大提高，红黑树在插入和删除节点只需要进行O（<span class="number">1</span>）次旋转和变色操作，即可保持平衡，而AVL树需要O（logn）次旋转操作。</span><br><span class="line">缺点：</span><br><span class="line">红黑树查询效率稍有下降，因为红黑树平衡性较弱。</span><br><span class="line">一些数据需要进行多次磁盘IO操作才能查询到，这也是MySQL没有选择红黑树的主要原因。</span><br><span class="line">红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1<span class="number">.8</span> 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</span><br></pre></td></tr></table></figure><h4 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B 树和 B+ 树"></a>B 树和 B+ 树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B 树也称B-树,全称为多路平衡查找树，B+树是B树的一种变体。</span><br></pre></td></tr></table></figure><h5 id="B-树和-B-树区别"><a href="#B-树和-B-树区别" class="headerlink" title="B 树和 B+ 树区别"></a>B 树和 B+ 树区别</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</span><br><span class="line"><span class="number">2</span>、B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</span><br><span class="line"><span class="number">3</span>、B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</span><br><span class="line"><span class="number">4</span>、在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</span><br><span class="line">综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</span><br></pre></td></tr></table></figure><h4 id="非聚簇索引和聚簇索引"><a href="#非聚簇索引和聚簇索引" class="headerlink" title="非聚簇索引和聚簇索引"></a>非聚簇索引和聚簇索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyISAM引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引（非聚集索引）</span><br><span class="line">    </span><br><span class="line">InnoDB 引擎中，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（聚集索引），而其余的索引都作为 辅助索引 ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。</span><br><span class="line">在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</span><br></pre></td></tr></table></figure><h3 id="索引类型总结"><a href="#索引类型总结" class="headerlink" title="索引类型总结"></a>索引类型总结</h3><h4 id="数据结构划分"><a href="#数据结构划分" class="headerlink" title="数据结构划分"></a>数据结构划分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。</span><br><span class="line">哈希索引：类似键值对的形式，一次即可定位。</span><br><span class="line">RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</span><br><span class="line">全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</span><br></pre></td></tr></table></figure><h4 id="底层存储方式划分"><a href="#底层存储方式划分" class="headerlink" title="底层存储方式划分"></a>底层存储方式划分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB中的主键索引就属于聚簇索引。</span><br><span class="line">非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引（辅助索引）就属于非聚簇索引。MyISAM引擎不管主键还是非主键，使用的都是非聚簇索引。</span><br></pre></td></tr></table></figure><h4 id="应用维度划分"><a href="#应用维度划分" class="headerlink" title="应用维度划分"></a>应用维度划分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">主键索引：加速查询+列表唯一（不可以有NULL）+表中只有一个。</span><br><span class="line">普通索引：加速查询</span><br><span class="line">唯一索引：加速查询+列表唯一（可以有NULL）</span><br><span class="line">覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</span><br><span class="line">联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</span><br><span class="line">全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</span><br></pre></td></tr></table></figure><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据表的主键使用的就是主键索引。</span><br><span class="line">一张数据表只能有一个主键，并且主键不能为NULL，不能重复。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/6d66ae1efd90ef6108c1b.png"></p><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说通过二级主键，可以也只能定位主键位置。</span><br><span class="line">唯一索引，普通索引，前缀索引等索引属于二级索引。</span><br><span class="line">唯一索引（Unique Key）:建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</span><br><span class="line">普通索引（Index）:</span><br><span class="line">前缀索引(Prefix):前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</span><br><span class="line">全文索引（Full Text）:</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/6d66ae1efd90ef6108c1b.png"></p><h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB中的主键索引就属于聚簇索引。</span><br></pre></td></tr></table></figure><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line"><span class="number">1</span>、查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</span><br><span class="line"><span class="number">2</span>、对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。</span><br><span class="line">缺点：</span><br><span class="line"><span class="number">1</span>、依赖于有序的数据：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</span><br><span class="line"><span class="number">2</span>、更新代价大：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</span><br></pre></td></tr></table></figure><h4 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">非聚簇索引即索引结构和数据分开存放的素银，并不是一种单独的索引类型。二级索引（辅助索引）就属于非聚簇索引。MyISAM引擎，不管主键还是非主键，使用的都是非聚簇索引。</span><br><span class="line">非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据</span><br></pre></td></tr></table></figure><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line"><span class="number">1</span>、更新代价比聚簇索引要小。非聚簇索引的叶子节点是不存放数据的。</span><br><span class="line">缺点：</span><br><span class="line"><span class="number">1</span>、依赖于有序的数据</span><br><span class="line"><span class="number">2</span>、可能会二次查询（回表）：当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</span><br></pre></td></tr></table></figure><h4 id="非聚簇索引一定回表查询吗"><a href="#非聚簇索引一定回表查询吗" class="headerlink" title="非聚簇索引一定回表查询吗"></a>非聚簇索引一定回表查询吗</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">非聚簇索引不一定回表查询。</span><br><span class="line">假设用户名有索引，当查询语句只需要查询用户名时，查到对应name就直接返回，无需回表查询</span><br></pre></td></tr></table></figure><h3 id="覆盖索引和联合索引"><a href="#覆盖索引和联合索引" class="headerlink" title="覆盖索引和联合索引"></a>覆盖索引和联合索引</h3><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果一个索引包含所有需要查询的字段的值，我们就称之为 覆盖索引（Covering Index） 。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</span><br><span class="line">    </span><br><span class="line">所以覆盖索引指的是一种情况,即索引的字段刚好能满足查询需求，不需要回表即可满足查询的情况。</span><br><span class="line">覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</span><br><span class="line">比如刚刚的非聚簇索引不一定回表查询的情况，就是覆盖索引。</span><br></pre></td></tr></table></figure><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用多个字段创建索引就是联合索引。</span><br></pre></td></tr></table></figure><h4 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最左前缀匹配原则指的是，在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 &gt;、&lt; ）才会停止匹配。对于 &gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ">全网都在说一个错误的结论 (qq.com)</a></p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引下推（Index Condition Pushdown） 是 MySQL <span class="number">5.6</span> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</span><br></pre></td></tr></table></figure><h3 id="正确使用索引的一些建议"><a href="#正确使用索引的一些建议" class="headerlink" title="正确使用索引的一些建议"></a>正确使用索引的一些建议</h3><h3 id="锁加在索引上如何理解"><a href="#锁加在索引上如何理解" class="headerlink" title="锁加在索引上如何理解"></a>锁加在索引上如何理解</h3><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL日志主要包裹错误日志，查询日志，慢查询日志，事务日志，二进制日志几大类。其中比较重要的是二进制日志binlog（归档日志）和事务日志redolog（重做日志）和回滚日志undolog</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/628d76e5886cc9c4cb60d.png"></p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redo log（重做日志，事务日志）是InnoDB存储引擎特有的，它让MySQL拥有了崩溃恢复能力。</span><br><span class="line">当MySQL宕机了，重启时InnoDB存储引擎会使用redo log恢复数据，，保证数据的持久性与完整性。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/7faff3b662e0921325aa0.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MySQL中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。</span><br><span class="line">后续的查询都是先从 Buffer Pool中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。</span><br><span class="line">更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/223dcbd519f28faf14fa0.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">具体刷盘时机根据策略进行。</span><br><span class="line">每条redo记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</span><br></pre></td></tr></table></figure><h4 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InnoDB将redo log刷到磁盘上有几种情况：</span><br><span class="line"><span class="number">1</span>、事务提交：当事务提交时，log buffer里的redo log会被刷新到磁盘。</span><br><span class="line"><span class="number">2</span>、log buffer空间不足时：log buffer中缓存的redo log已经占满了log buffer总容量大约一半左右，就需要把这些日志刷新到磁盘上。</span><br><span class="line"><span class="number">3</span>、事务日志缓冲区满时：InnoDB 使用一个事务日志缓冲区（transaction log buffer）来暂时存储事务的重做日志条目。当缓冲区满时，会触发日志的刷新，将日志写入磁盘。</span><br><span class="line"><span class="number">4</span>、Checkpoint（检查点）：InnoDB 定期会执行检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。</span><br><span class="line"><span class="number">5</span>、后台刷新线程：InnoDB 启动了一个后台线程，负责周期性（每隔 <span class="number">1</span> 秒）地将脏页（已修改但尚未写入磁盘的数据页）刷新到磁盘，并将相关的重做日志一同刷新。</span><br><span class="line"><span class="number">6</span>、正常关闭服务器：MySQL 关闭的时候，redo log 都会刷入到磁盘里去。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以通过设置innodb_flush_log_at_trx_commit选择刷盘策略。</span><br><span class="line">innodb_flush_log_at_trx_commit的值有<span class="number">3</span>种，也就是有三种刷盘策略：</span><br><span class="line"><span class="number">0</span>：设置为<span class="number">0</span>的时候，表示每次事务提交时不进行刷盘操作。这种方式性能最高，但是也最不安全，因为如果MySQL挂了或者宕机了，可能会丢失最近<span class="number">1</span>秒内的事务。</span><br><span class="line"><span class="number">1</span>：设置为 <span class="number">1</span> 的时候，表示每次事务提交时都将进行刷盘操作。这种方式性能最低，但是也最安全，因为只要事务提交成功，redo log 记录就一定在磁盘里，不会有任何数据丢失。</span><br><span class="line"><span class="number">2</span>：设置为 <span class="number">2</span> 的时候，表示每次事务提交时都只把 log buffer 里的 redo log 内容写入 page cache（文件系统缓存）。page cache 是专门用来缓存文件的，这里被缓存的文件就是 redo log 文件。这种方式的性能和安全性都介于前两者中间。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了保证事务的持久性，必须设置为<span class="number">1</span>。</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h4 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">硬盘上存储的redo log日志文件是以日志文件组的形式出现，每个redo log日志文件大小都是一样的。</span><br><span class="line">比如可以配置一组<span class="number">4</span>个文件。</span><br><span class="line">它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/4059871cd38e435bc0231.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint</span><br><span class="line">write pos 是当前记录的位置，一边写一边后移</span><br><span class="line">checkpoint 是当前要擦除的位置，也是往后推移</span><br><span class="line">    </span><br><span class="line">每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。</span><br><span class="line">每次 MySQL 加载日志文件组恢复数据时，会清空加载过的redo log记录，并把 checkpoint 后移更新。write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/f31d0657e3a8de73eee8d.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果 write pos 追上checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/ecf38596b47d62049c1c1.png"></p><h4 id="redo-log-小结"><a href="#redo-log-小结" class="headerlink" title="redo log 小结"></a>redo log 小结</h4><h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redo log是物理日志，记录内容是“在某个数据页做了什么修改”，属于InnoDB存储引擎。</span><br><span class="line">而binlog是逻辑日志，记录内容是语句的原始逻辑，类似于“给ID=<span class="number">2</span>这一行c字段加<span class="number">1</span>”，属于MySQL Server层</span><br><span class="line">不管什么存储引擎，只要产生表数据更新，都会产生binlog日志。</span><br></pre></td></tr></table></figure><h4 id="binlog-到底是用来干嘛的？"><a href="#binlog-到底是用来干嘛的？" class="headerlink" title="binlog 到底是用来干嘛的？"></a>binlog 到底是用来干嘛的？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/0354d53b0cb4fa2d9e633.png"></p><h4 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">binlog日志有三种格式，可以通过binlog_format参数指定。</span><br><span class="line">statement</span><br><span class="line">row</span><br><span class="line">mixed</span><br></pre></td></tr></table></figure><h5 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定statement格式，记录的内容是SQL语句原文，比如执行一条update T set update_time=now() where id=<span class="number">1</span>，记录的内容如下。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/1b1c3a1c450d53297799f.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是有个问题，当同步数据时，update_time=now()会获取当前系统时间，会导致数据不一致。为了解决这个问题，需要指定row格式。</span><br></pre></td></tr></table></figure><h5 id="row"><a href="#row" class="headerlink" title="row"></a>row</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row格式记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/fc888a094e0272e237784.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">row格式记录的内容看不到详细信息，要通过mysqlbinlog工具解析出来。</span><br><span class="line">update_time=now()变成了具体的时间update_time=<span class="number">1627112756247</span>，条件后面的@<span class="number">1</span>、@<span class="number">2</span>、@<span class="number">3</span> 都是该行数据第 <span class="number">1</span> 个~<span class="number">3</span> 个字段的原始值（假设这张表只有 <span class="number">3</span> 个字段）。</span><br><span class="line">这样就能保证同步数据的一致性。</span><br><span class="line">但是这种格式需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。</span><br><span class="line">所以有一种折中方式，mixed，记录内容是前两者混合。</span><br></pre></td></tr></table></figure><h5 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL会判断这条SQL语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式。</span><br></pre></td></tr></table></figure><h4 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h4><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redo log（重做日志）让InnoDB存储引擎拥有了崩溃恢复能力。</span><br><span class="line">binlog（归档日志）保证了MySQL集群架构的数据一致性。</span><br><span class="line">虽然它们都属于持久化的保证，但是侧重点不同。</span><br><span class="line">在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/c686fac543e1b7821c130.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们以update语句为例，假设id=<span class="number">2</span>的记录，字段c值是<span class="number">0</span>，把字段c值更新成<span class="number">1</span>，</span><br><span class="line">SQL语句为update T set c=<span class="number">1</span> where id=<span class="number">2</span>。</span><br><span class="line">假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢？</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/ae5492e016c3bb084bd0b.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。因此，之后用binlog日志恢复数据时，就会少这一次更新，恢复出来的这一行c值是<span class="number">0</span>，而原库因为redo log日志恢复，这一行c值是<span class="number">1</span>，最终数据不一致。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/d0e58755e58a9e984279a.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用两阶段提交方案。</span><br><span class="line">原理很简单，将redo log的写入拆成了两个步骤prepare和commit，这就是两阶段提交。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/c0576705bdaa3a829d155.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用**两阶段提交**后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/c01d55f89517c3d1b9786.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">再看一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</span><br><span class="line">并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/c01d55f89517c3d1b9786.png"></p><h3 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">undo log主要有两个作用：</span><br><span class="line">当事务回滚时用于将数据恢复到修改前的样子</span><br><span class="line">另一个作用是MVCC，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过undo log读取之前的版本数据，以此实现非锁定读</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事务是逻辑上要一组操作要么全部执行，要么全部不执行</span><br></pre></td></tr></table></figure><h3 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ACID:</span><br><span class="line">原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</span><br><span class="line">一致性：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的 </span><br><span class="line">隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</span><br><span class="line">持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响 </span><br><span class="line">这里要额外补充一点：只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</span><br></pre></td></tr></table></figure><h3 id="并发事务带来什么问题"><a href="#并发事务带来什么问题" class="headerlink" title="并发事务带来什么问题"></a>并发事务带来什么问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</span><br><span class="line">例如：事务 <span class="number">1</span> 读取某表中的数据 A=<span class="number">20</span>，事务 <span class="number">1</span> 修改 A=A-<span class="number">1</span>，事务 <span class="number">2</span> 读取到 A = <span class="number">19</span>,事务 <span class="number">1</span> 回滚导致对 A 的修改并未提交到数据库， A 的值还是 <span class="number">20</span>。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/1a19d504e7169507b2f63.png"></p><h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务 <span class="number">1</span> 读取某表中的数据A=<span class="number">20</span>，事务 <span class="number">2</span> 也读取 A=<span class="number">20</span>，事务 <span class="number">1</span> 先修改 A=A-<span class="number">1</span>，事务 <span class="number">2</span> 后来也修改 A=A-<span class="number">1</span>，最终结果 A=<span class="number">19</span>，事务 <span class="number">1</span> 的修改被丢失。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/43c7ce0d40b85a94006f9.png"></p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。例如：事务 <span class="number">1</span> 读取某表中的数据 A=<span class="number">20</span>，事务 <span class="number">2</span> 也读取 A=<span class="number">20</span>，事务 <span class="number">1</span> 修改 A=A-<span class="number">1</span>，事务 <span class="number">2</span> 再次读取 A =<span class="number">19</span>，此时读取的结果和第一次读取的结果不同。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/507a6ed82383644083638.png"></p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。例如：事务 <span class="number">2</span> 读取某个范围的数据，事务 <span class="number">1</span> 在这个范围插入了新的数据，事务 <span class="number">2</span> 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/29b5d2953aaec14393e25.png"></p><h4 id="不可重复读和幻读有什么区别"><a href="#不可重复读和幻读有什么区别" class="headerlink" title="不可重复读和幻读有什么区别"></a>不可重复读和幻读有什么区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</span><br><span class="line">幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</span><br><span class="line">注意：记录减少是不可重复读。update和delete是不可重复读，insert是幻读</span><br><span class="line">    </span><br><span class="line">幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。举个例子：执行 delete 和 update 操作的时候，可以直接对记录加锁，保证事务安全。而执行 insert 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 insert 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</span><br></pre></td></tr></table></figure><h3 id="并发事务的控制方式有哪些"><a href="#并发事务的控制方式有哪些" class="headerlink" title="并发事务的控制方式有哪些"></a>并发事务的控制方式有哪些</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL中的并发事务控制方式分为两种：锁和MVCC。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</span><br></pre></td></tr></table></figure><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">锁 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过读写锁来实现并发控制。</span><br><span class="line">共享锁（S锁），又称为读锁，事务在读取记录时获取共享锁，允许多个事务同时获取（锁兼容）</span><br><span class="line">排他锁（x锁），又称为写锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</span><br><span class="line">读写锁可以做到读读并行，但是无法做到写读、写写并行</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据根据锁粒度的不同，又被分为 表级锁(table-level locking) 和 行级锁(row-level locking) 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</span><br></pre></td></tr></table></figure><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</span><br><span class="line">READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</span><br><span class="line">REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。MySQL默认隔离级别。</span><br><span class="line">SERIALIZABLE（可串行化）：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/71982df79bc6f60860753.png"></p><h2 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a>锁</h2><h3 id="表级锁和行级锁"><a href="#表级锁和行级锁" class="headerlink" title="表级锁和行级锁"></a>表级锁和行级锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表级锁：是针对非索引字段加的锁，对当前操作的整张表加锁，资源消耗少，不会出现死锁。不过容易发生冲突，高并发下效率低。</span><br><span class="line">行级锁：是针对索引字段加的锁，只针对当前操作的行记录进行加锁。资源消耗大，会出现死锁，但大大减少冲突，高并发下效率高。</span><br></pre></td></tr></table></figure><h3 id="行级锁的使用有什么注意事项"><a href="#行级锁的使用有什么注意事项" class="headerlink" title="行级锁的使用有什么注意事项"></a>行级锁的使用有什么注意事项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 UPDATE、DELETE 语句时，如果 WHERE条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</span><br><span class="line">不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、怎么理解行锁是针对索引字段加的锁，表锁是针对非索引字段加的锁，索引不同会怎么样？</span><br><span class="line"><span class="number">2</span>、整理加锁情况，锁优化情况，锁退化情况</span><br></pre></td></tr></table></figure><h3 id="行锁分类"><a href="#行锁分类" class="headerlink" title="行锁分类"></a>行锁分类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MySQL有三种行锁：</span><br><span class="line">记录锁（Record Lock）：也被称为记录锁，属于单个行记录上的锁。</span><br><span class="line">间隙锁（Gap Lock）：锁定一个范围，不包括记录本身。</span><br><span class="line">临键锁（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</span><br></pre></td></tr></table></figure><h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前面有记录</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">由于MVCC存在，对于一般的SELECT语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</span><br><span class="line">    </span><br><span class="line"># 共享锁 可以在 MySQL <span class="number">5.7</span> 和 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br><span class="line"># 共享锁 可以在 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line">SELECT ... FOR SHARE;</span><br><span class="line"># 排他锁</span><br><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那为什么由于MVCC存在，select不加锁，delete，insert，update又是怎样呢</span><br></pre></td></tr></table></figure><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><h3 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h3><h3 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">快照读（一致性非锁定读）就是单纯的 SELECT 语句，但不包括下面这两类 SELECT 语句：</span><br><span class="line">SELECT ... FOR UPDATE</span><br><span class="line"># 共享锁 可以在 MySQL <span class="number">5.7</span> 和 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br><span class="line"># 共享锁 可以在 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line">SELECT ... FOR SHARE;</span><br></pre></td></tr></table></figure><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MVCC是InnoDB引擎特有的</span><br><span class="line">MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</span><br></pre></td></tr></table></figure><h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、读操作（SELECT）：</span><br><span class="line">当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体工作情况如下：</span><br><span class="line"><span class="number">1</span>、对于读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。</span><br><span class="line"><span class="number">2</span>、如果某个数据行有多个版本，事务会选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。</span><br><span class="line"><span class="number">3</span>、事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、写操作（INSERT、UPDATE、DELETE）：</span><br><span class="line">当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库。具体工作情况如下：</span><br><span class="line"><span class="number">1</span>、对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。</span><br><span class="line"><span class="number">2</span>、新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。</span><br><span class="line"><span class="number">3</span>、原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、事务提交和回滚：</span><br><span class="line"><span class="number">1</span>、当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。</span><br><span class="line"><span class="number">2</span>、当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、版本的回收：</span><br><span class="line">为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。</span><br></pre></td></tr></table></figure><h3 id="一致性非锁定读和锁定读"><a href="#一致性非锁定读和锁定读" class="headerlink" title="一致性非锁定读和锁定读"></a>一致性非锁定读和锁定读</h3><h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于一致性非锁定读的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + <span class="number">1</span> 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见</span><br><span class="line"></span><br><span class="line">在 InnoDB 存储引擎中，多版本控制就是对非锁定读的实现。**如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会去等待行上锁的释放。相反地，InnoDB 存储引擎会去读取行的一个快照数据**，对于这种读取历史数据的方式，我们叫它快照读。</span><br><span class="line">在Repeatable Read 和Read Committed两个隔离级别下，如果是执行普通的 select 语句（不包括 select ... lock in share mode ,select ... <span class="keyword">for</span> update）则会使用一致性非锁定读（MVCC）。并且在 Repeatable Read 下 MVCC 实现了可重复读和防止部分幻读</span><br></pre></td></tr></table></figure><h4 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果执行的是下列语句，就是锁定读（Locking Reads）</span><br><span class="line">select ... lock in share mode</span><br><span class="line">select ... <span class="keyword">for</span> update</span><br><span class="line">insert、update、delete 操作</span><br><span class="line"></span><br><span class="line">在锁定读下，读取的是数据的最新版本，这种读也被称为当前读（current read）。锁定读会对读取到的记录加锁：</span><br><span class="line">select ... lock in share mode：对记录加 S 锁，其它事务也可以加S锁，如果加 x 锁则会被阻塞</span><br><span class="line">select ... <span class="keyword">for</span> update、insert、update、delete：对记录加 X 锁，且其它事务不能加任何锁</span><br><span class="line"></span><br><span class="line">在一致性非锁定读下，即使读取的记录已被其它事务加上 X 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在Repeatable Read 下MVCC防止了部分幻读，这边的 “部分” 是指在一致性非锁定读 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是如果是当前读 ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， **InnoDB 在实现Repeatable Read时，如果执行的是当前读，则会对读取的记录使用 Next-key Lock ，来防止其它事务在间隙间插入数据**</span><br></pre></td></tr></table></figure><h3 id="InnoDB-对-MVCC-的实现"><a href="#InnoDB-对-MVCC-的实现" class="headerlink" title="InnoDB 对 MVCC 的实现"></a>InnoDB 对 MVCC 的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVCC的实现依赖于：**隐藏字段、Read View、undo log**。在内部实现中，InnoDB通过数据行的DB_TRX_ID 和Read View来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</span><br></pre></td></tr></table></figure><h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在内部，InnoDB 存储引擎为每行数据添加了三个 隐藏字段：</span><br><span class="line">DB_TRX_ID（<span class="number">6</span>字节）：表示最后一次插入或更新该行的事务 id。此外，delete 操作在内部被视为更新，只不过会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除</span><br><span class="line">DB_ROLL_PTR（<span class="number">7</span>字节） 回滚指针，指向该行的 undo log 。如果该行未被更新，则为空</span><br><span class="line">DB_ROW_ID（<span class="number">6</span>字节）：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引</span><br></pre></td></tr></table></figure><h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadView</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  trx_id_t m_low_limit_id;      <span class="comment">/* 大于等于这个 ID 的事务均不可见 */</span></span><br><span class="line"></span><br><span class="line">  trx_id_t m_up_limit_id;       <span class="comment">/* 小于这个 ID 的事务均可见 */</span></span><br><span class="line"></span><br><span class="line">  trx_id_t m_creator_trx_id;    <span class="comment">/* 创建该 Read View 的事务ID */</span></span><br><span class="line"></span><br><span class="line">  trx_id_t m_low_limit_no;      <span class="comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span></span><br><span class="line"></span><br><span class="line">  ids_t m_ids;                  <span class="comment">/* 创建 Read View 时的活跃事务列表 */</span></span><br><span class="line"></span><br><span class="line">  m_closed;                     <span class="comment">/* 标记 Read View 是否 close */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主要有以下字段：</span><br><span class="line">m_low_limit_id：目前出现过的最大的事务ID+<span class="number">1</span>，即下一个将被分配的事务ID。大于等于这个ID的数据版本均不可见</span><br><span class="line">m_up_limit_id：活跃事务列表 m_ids 中最小的事务 ID，如果 m_ids 为空，则 m_up_limit_id 为 m_low_limit_id。小于这个 ID 的数据版本均可见</span><br><span class="line">m_ids：Read View创建时其他未提交的活跃事务ID列表。创建Read View时，将当前未提交事务ID记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。m_ids不包括当前事务自己和已提交的事务（正在内存中）</span><br><span class="line">m_creator_trx_id：创建该 Read View 的事务 ID</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/a205da303f63160c9a0ca.png"></p><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo-log"></a>undo-log</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">undo log主要有两个作用：</span><br><span class="line">当事务回滚时用于将数据恢复到修改前的样子</span><br><span class="line">另一个作用是MVCC ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过undo log 读取之前的版本数据，以此实现非锁定读</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 InnoDB 存储引擎中 undo log 分为两种：insert undo log 和 update undo log：</span><br><span class="line">insert undo log：指在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对其他事务不可见，故该 undo log 可以在事务提交后直接删除。不需要进行 purge 操作</span><br><span class="line">insert 时的数据初始状态：</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/9cf0449f3ad9b65edc151.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update undo log：update 或 delete 操作中产生的 undo log。该 undo log可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。提交时放入 undo log 链表，等待 purge线程 进行最后的删除</span><br><span class="line">数据第一次被修改时：</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/6caae7a0439123b9a032c.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据第二次被修改时：</span><br></pre></td></tr></table></figure><p><img src="https://telegraph-image-5ol.pages.dev/file/53ee0b67407e360a9afd1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不同事务或者相同事务的对同一记录行的修改，会使该记录行的 undo log 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录。</span><br></pre></td></tr></table></figure><h4 id="数据可见性算法"><a href="#数据可见性算法" class="headerlink" title="数据可见性算法"></a>数据可见性算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 InnoDB 存储引擎中，创建一个新事务后，执行每个select 语句前都会创建一个快照（Read View），**快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号**。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，InnoDB 会将该记录行的 DB_TRX_ID 与 Read View 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</span><br></pre></td></tr></table></figure><h3 id="RC-和-RR-隔离级别下-MVCC-的差异"><a href="#RC-和-RR-隔离级别下-MVCC-的差异" class="headerlink" title="RC 和 RR 隔离级别下 MVCC 的差异"></a>RC 和 RR 隔离级别下 MVCC 的差异</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在事务隔离级别 RC 和 RR （InnoDB 存储引擎的默认事务隔离级别）下，InnoDB 存储引擎使用 MVCC（非锁定一致性读），但它们生成 Read View 的时机却不同</span><br><span class="line">在 RC 隔离级别下的 **每次select** 查询前都生成一个Read <span class="title function_">View</span> <span class="params">(m_ids 列表)</span></span><br><span class="line">在 RR 隔离级别下只在事务开始后 **第一次select** 数据前生成一个Read View（m_ids 列表）</span><br></pre></td></tr></table></figure><h3 id="MVCC-解决不可重复读问题"><a href="#MVCC-解决不可重复读问题" class="headerlink" title="MVCC 解决不可重复读问题"></a>MVCC 解决不可重复读问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虽然RC和RR都通过MVCC来读取快照数据，但由于生成Read View时机不同，从而在RR级别下实现可重复读</span><br><span class="line">总结： 在RC隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读</span><br></pre></td></tr></table></figure><h3 id="MVCC➕Next-key-Lock-防止幻读"><a href="#MVCC➕Next-key-Lock-防止幻读" class="headerlink" title="MVCC➕Next-key-Lock 防止幻读"></a>MVCC➕Next-key-Lock 防止幻读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InnoDB存储引擎在 RR 级别下通过 MVCC和 Next-key Lock 来解决幻读问题：</span><br><span class="line">**<span class="number">1</span>、执行普通 select，此时会以 MVCC 快照读的方式读取数据**</span><br><span class="line">在快照读的情况下，RR隔离级别只会在事务开启后的第一次查询生成Read View ，并使用至事务提交。所以在生成Read View之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</span><br><span class="line"></span><br><span class="line">**<span class="number">2</span>、执行 select...<span class="keyword">for</span> update/lock in share mode、insert、update、delete 等当前读**</span><br><span class="line">在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lock来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</span><br></pre></td></tr></table></figure><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h2 id="SQL-语句在-MySQL-中的执行过程"><a href="#SQL-语句在-MySQL-中的执行过程" class="headerlink" title="SQL 语句在 MySQL 中的执行过程"></a>SQL 语句在 MySQL 中的执行过程</h2><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="关系型数据库" scheme="http://example.com/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>音乐</title>
    <link href="http://example.com/2023/12/15/%E9%9F%B3%E4%B9%90/"/>
    <id>http://example.com/2023/12/15/%E9%9F%B3%E4%B9%90/</id>
    <published>2023-12-14T16:00:00.000Z</published>
    <updated>2023-12-16T01:49:04.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="aplayer-xtnywrMM" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"><pre class="aplayer-lrc-content">[00:00.000] 作词 : TK[00:00.310] 作曲 : TK[00:00.620]教えて 教えてよ その仕組みを[00:07.410]僕の中に 誰がいるの?[00:15.120]壊れた 壊れたよ この世界で[00:21.720]君が笑う[00:25.600]何も見えずに[00:41.500][00:41.600]壊れた 僕なんてさ[00:44.880]息を止めて[00:48.410]ほどけない もう ほどけないよ 真実さえ[00:54.890]freeze[00:55.480]壊せる[00:56.330]壊せない[00:57.370]狂える[00:58.390]狂えない[00:59.070]あなたを見つけて[01:01.610]揺れた[01:02.600][01:02.670]歪んだ世界にだんだん僕は 透き通って見えなくなって[01:09.850]見つけないで 僕のことを[01:15.570]見つめないで[01:17.040]誰かが描いた世界の中で あなたを傷つけたくはないよ[01:24.040]覚えていて 僕のことを?[01:33.210]鮮やかなまま[01:42.200][01:42.260]無限に広がる孤独が絡まる 無邪気に笑った記憶が刺さって[01:48.880]動けないく 動けないく 動けないく 動けないく 動けないく 動けないよ[01:55.510]unravelling the world[02:24.600][02:24.780]変わってしまった 変えられなかった[02:28.120]2つが絡まる 2人が滅びる[02:31.700]壊せる[02:32.320]壊せない[02:33.340]狂える[02:34.370]狂えない[02:35.080]あなたを汚せないよ[02:37.920]揺れた[02:38.900][02:38.940]歪んだ世界にだんだん僕は 透き通って見えなくなって[02:45.910]見つけないで 僕のことを[02:51.600]見つめないで[02:52.880]誰かが仕組んだ孤独な罠に 未来がほどけてしまう前に[02:59.890]思い出して 僕のことを[03:07.280]鮮やかなまま[03:10.900][03:10.910]忘れないで 忘れないで 忘れないで 忘れないで[03:17.700][03:17.720]変わってしまったことにparalyze[03:21.340]変えられないことだらけのparadise[03:24.950]覚えていて 僕のことを[03:35.800][03:35.840]教えて[03:39.380]教えて[03:42.840]僕の中に 誰がいるの?</pre></div><script>var ap = new APlayer({element: document.getElementById("aplayer-xtnywrMM"),narrow: false,autoplay: true,showlrc: 2,music: {title: "unravel",author: "凛として時雨",url: "/music/东京喰种.mp3",pic: "https://telegraph-image-5ol.pages.dev/file/b1d43ca4dc69e9e978992.jpg",}});window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="音乐" scheme="http://example.com/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
  </entry>
  
  <entry>
    <title>视频</title>
    <link href="http://example.com/2023/12/15/%E8%A7%86%E9%A2%91/"/>
    <id>http://example.com/2023/12/15/%E8%A7%86%E9%A2%91/</id>
    <published>2023-12-14T16:00:00.000Z</published>
    <updated>2023-12-16T01:48:50.003Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="/move/视频.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="视频" scheme="http://example.com/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
</feed>
